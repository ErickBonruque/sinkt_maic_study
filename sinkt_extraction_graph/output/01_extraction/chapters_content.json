[
    {
        "chapter_id": "1",
        "title": "Capítulo 1",
        "content": "# **1**\n\n## Introdução ao Linux\n\n### **Sobre o material**\n\nExistem basicamente dois tipos de materiais de estudo: os materiais de referência e os tutoriais.\nO material de referência é orientado para a consulta por quem já conhece um assunto e precisa\napenas relembrar ou necessita apenas de detalhes mais específicos sobre um tópico, como por\nexemplo, a sintaxe de um comando. Já o material do tipo tutorial visa ensinar um conceito\nou assunto. Ele tenta ensinar a quem não sabe como fazer algo, como usar os recursos e as\nferramentas disponíveis para atingir um determinado resultado.\n\n\nAmbos são muito importantes e úteis tanto para o estudante quanto para o profissional.\nAmbos servem para consulta futura, pois enquanto o material de referência será acessado\ncom mais frequência depois de acabada a etapa inicial de aprendizado, existem inúmeras\nmaneiras diferentes de se apresentar um assunto, refletindo as variações existentes no mundo\nreal. Então, mesmo quem já domina determinado assunto irá se beneficiar por estudar um\nnovo tutorial de vez em quando. Fora o fato de que podemos “esquecer” determinadas coisas\nse ficarmos algum tempo sem utilizá-las, então talvez seja necessário voltar aos tutoriais para\nrelembrar.\n\n\nAs apostilas deste curso são tutoriais. Não iremos apresentar todas as variações de sintaxe\nde um comando nem todas as diretivas de um arquivo de configuração. Isto é informação de\nreferência, que é melhor atendida pelas suas respectivas documentações oficiais.\n\n\nAcreditamos que o aluno não tem necessidade de “mais um” material de referência para\n\n\n6\n\n\n7 1. Introdução ao Linux\n\n\nLinux. Já existem materiais muito bons, disponíveis gratuitamente, mas acreditamos que\npodemos fazer a diferença com uma forma diferente de fazer tutoriais. Tentaremos seguir\numa abordagem de “aprender fazendo”, privilegiando exemplos de exercícios completos, que\n\n- aluno pode executar imediatamente.\n\n\nEsperamos que o aluno aprenda pela leitura e análise destes exemplos. Ainda assim, é importante complementar o material nestas apostilas com as referências apresentadas no nosso\nambiente virtual de ensino.\n\n\nTambém não temos a pretensão de escrever o “melhor tutorial do mundo”. Cada pessoa tem\nsua própria forma de ver o mundo e de aprender sobre os assuntos. Por isso indicaremos, no\nmaterial complementar, alguns outros tutoriais que serão úteis durante ou depois do curso\npara solidificar o seu entendimento do Linux.\n\n### **Mercado Linux**\n\n\nNesta seção, você será introduzido no mundo Open Source, veremos a importância do Linux\nno mundo atual e quais são as principais profissões do mercado que utilizam Linux atualmente.\nLogo, vamos responder a perguntas como:\n\n```\n  •\n```\n\nOnde podemos encontrar o Linux?\n\n```\n  •\n```\nPor onde posso começar usando o Linux?\n\n```\n  •\n```\nQuais as principais profissões envolvendo Linux?\n\n\n“Se o Windows domina no Desktop. . . o Linux domina o mundo!” Steve Ranger –\nZDnet\n\n\n**Onde podemos encontrar o Linux?**\n\n\nAtualmente, muitos nichos no mundo de tecnologia utilizam o Linux, começando pelo mercado\nde dispositivos móveis. Hoje o Android é o sistema operacional para dispositivos móveis mais\nutilizado no mundo. Não podemos deixar de falar sobre o mundo de segurança, testes de\ninvasão ou técnicas forenses sem conhecer Linux, pois muitas das ferramentas utilizadas nesse\nramo foram desenvolvidas para as distribuições Linux.\n\n\nHoje a computação em nuvem vem transformando muitos dos recursos tecnológicos das empresas em serviços prestados por provedores, nesses casos podendo fornecer, por exemplo,\ninfraestrutura sob demanda e a maior parte dos recursos que estão hoje na computação em\nnuvem são executados em ambientes Linux. Grandes provedores de serviços em nuvem, como\nAmazon Web Services (AWS), Google Cloud Platform (GCP), Oracle Cloud (OCI) e Digi\n\n8 1. Introdução ao Linux\n\n\ntal Ocean oferecem diferentes distribuições Linux e até mesmo a Microsoft oferece máquinas\nvirtuais baseadas em Linux em sua nuvem, chamada Azure.\n\n\nO mundo da Big Data também vem crescendo e atualmente as ferramentas para integração\ne tratamento de dados são executados em Linux.\n\n\nA DevOps é uma cultura aplicada para se obter principalmente a união entre os times de\ndesenvolvimento (dev) e operações (ops) e assim surgiram diversas operações e deveres de\nambas as áreas, muito disso funcionando dentro de ambientes Linux.\n\n\n**Market Share – Sistemas Operacionais pelo mundo**\n\n\nEm Março de 2017, a StatCounter anunciou o novo sistema operacional mais utilizado no\nmundo (levando em consideração apenas sistemas conectados à Internet).\n\n\nO Android é um sistema operacional baseado no kernel Linux, licenciado pelo GPLv2.\n\n\n“Este é um marco na história da tecnologia e o fim de uma era”, comentou Aodhan\nCullen, CEO da StatCounter. “Isso marca o fim da liderança mundial da Microsoft no\nmercado de sistemas operacionais, que detém desde os anos 1980. Também representa\num grande avanço para o Android, que detinha apenas 2,4% do uso global da Internet\nhá apenas cinco anos.”\n\n\n9 1. Introdução ao Linux\n\n\nAtualmente, o Android é o sistema operacional móvel mais utilizado no mundo (considerando\napenas sistemas conectados à Internet). Logo abaixo, temos um gráfico referente ao ano de\n2020:\n\n\n**Dispositivos móveis**\n\n\nEsse grande domínio do sistema operacional Android deve-se aos dispositivos móveis como os\nsmartphones. Abaixo temos um gráfico referente ao ano de 2020 para esses dispositivos:\n\n\n10 1. Introdução ao Linux\n\n\nConheça mais estatísticas em: https://gs.statcounter.com/.\n\n\n**Desktop Linux**\n\n\nAtualmente, o Linux ocupa cerca de 2% dos desktops. Mesmo não dominando os computadores domésticos, ainda são desenvolvidas diversas distribuições para a utilização do usuário\ncomum, muitas delas são até mesmo mais simples do que o próprio sistema de janelas da\nMicrosoft.\n\n\nAinda que as estações de trabalho não sejam muito utilizadas, a comunidade vem desenvolvendo interfaces cada vez mais amigáveis. A seguir temos uma breve listagem:\n\n```\n  •\n```\n\nElementary OS\n\n```\n  •\n```\nMX Linux\n\n```\n  •\n```\nLinux Mint\n\n```\n  •\n```\nDeepin\n\n```\n  •\n```\nManjaro OS\n\n```\n  •\n```\nPop!_OS\n\n```\n  •\n```\nUbuntu\n\n```\n  •\n```\nFedora\n\n\nConheça as distribuições mais utilizadas em: https://distrowatch.com.\n\n\n11 1. Introdução ao Linux\n\n\n**Servidores web**\n\n\nEm 2020, a W3Techs fez o relatório de Market Share dos servidores web mais utilizados\nbaseado nos sistemas operacionais:\n\n\n**Profissões no mundo OpenSource**\n\n\nAlguns dados sobre o relatório de vagas de trabalho no mercado do código aberto em 2020\ngerado pela Linux Foundation e pela edX:\n\n```\n  •\n```\n\nCerca de 93% dos gerentes de contratação relatam dificuldade em encontrar talentos na\nárea de código aberto e 63% dizem que suas organizações começaram a apoiar projetos\nde código aberto com contribuições sob a forma de código ou outros recursos pelo motivo\nexplícito de recrutar indivíduos com essas habilidades de software, um salto significativo\ndos 48% conhecidos em 2018. DevOps também se tornou a principal função que os\ngerentes de contratação estão procurando preencher (65% estão procurando contratar\ntalentos DevOps), movendo a demanda por desenvolvedores para o segundo lugar.\n\n```\n  •\n```\nPela primeira vez na história deste relatório, 74% dos empregadores agora estão se\n\n\n12 1. Introdução ao Linux\n\n\noferecendo para pagar pelas certificações de seus funcionários.\n\n```\n  •\n```\nAs certificações crescem em importância: 52% dos gerentes de contratação são mais\npropensos a contratar alguém com uma certificação, contra 47% há dois anos.\n\n```\n  •\n```\nA tecnologia de nuvem está aquecida: em termos de domínio de conhecimento, os\ngerentes de contratação relatam que conhecimentos em tecnologias de nuvem aberta tem\n\n   - impacto mais significativo, e 70% deles está mais propenso a contratar um profissional\ncom essas habilidades, contra 66% em 2018.\n\n\nTecnologias da mais alta importância para profissionais de código aberto em 2020:\n\n\nAlguns dos muitos cargos que estão em alta no mundo Open Source:\n\n```\n  •\n```\n\nAnalista DevOps\n\n```\n  •\n```\nAnalista SRE\n\n```\n  •\n```\nAdministrador de Servidores\n\n```\n  •\n```\nDesenvolvedor de Software\n\n```\n  •\n```\nEngenheiro de Software\n\n```\n  •\n```\nAnalista de Banco de Dados\n\n```\n  •\n```\nEngenheiro de Dados\n\n```\n  •\n```\nCientista de Dados\n\n```\n  •\n```\nEngenheiro de Machine Learning\n\n```\n  •\n```\nAnalista de Segurança\n\n```\n  •\n```\nGerente de TI\n\n```\n  •\n```\nDiretor Chefe de Tecnologia"
    },
    {
        "chapter_id": "2",
        "title": "Capítulo 2",
        "content": "# **2**\n\n## Certificações Linux\n\n“A premissa de qualquer certificação é que ela ajude um gerente de contratações a\norganizar a pilha de currículos”. – Randy Russel, Diretor de contratações e certificação\nda Red Hat.\n\n### **Centros certificadores**\n\n\nExistem diversas carreiras e centros de formação para certificar profissionais em Linux. Atualmente os mais buscados são: LPI ( _Linux Professional Institute_ ), RedHat e Linux Foundation,\nque vem crescendo com o tempo. Até mesmo a Microsoft fechou parceria com a Linux\n\n\n13\n\n\n14 2. Certificações Linux\n\n\nFoundation no mesmo ano em que disponibilizou o SQLServer para plataformas Linux.\n\n\nAlém dos centros citados acima, também temos outros como OpenSuse, CompTIA+ e a\nprópria Exin que disponibilizou uma excelente certificação de DevOps.\n\n\n**Linux Professional Institute**\n\n\nAlguns pontos importantes a serem observados sobre o LPI:\n\n```\n  •\n```\n\nÉ uma organização sem fins lucrativos;\n\n```\n  •\n```\nCertificação independente de fornecedores;\n\n```\n  •\n```\nO conteúdo dos exames são baseados no padrão LSB ( _Linux Standard Base_ );\n\n`•` Nas palavras de Jon Maddog Hall: **“É a maior certificação mundial em Linux”** ;\n\n```\n  •\n```\nAs provas são aplicadas pelo LPI Brasil ou pelo centro de treinamento VUE;\n\n```\n  •\n```\nAs provas são aplicadas em português apenas nos níveis 1 e 2;\n\n```\n  •\n```\nO tempo de validade é de 5 anos;\n\n```\n  •\n```\nPara obter as certificações de nível 1 e 2 são realizadas duas provas;\n\n```\n  •\n```\nPara obter a certificação nível 3 é realizada apenas uma prova.\n\n\n**Red Hat Certificate**\n\n```\n  •\n```\n\nDentre as versões Linux comerciais, a Red Hat tem o mais popular programa de certificação do mercado;\n\n```\n  •\n```\nAs provas são práticas;\n\n```\n  •\n```\nO conteúdo dos exames são baseados sempre na versão mais recente do Linux Red Hat\nEnterprise.\n\n\nO programa de certificação da RedHat possui as seguintes certificações:\n\n```\n  •\n```\n\nRed Hat Certied System Administrator\n\n```\n  •\n```\nRed Hat Certied Engineer\n\n```\n  •\n```\nRed Hat Certied Architect\n\n\n**Linux Foundation**\n\n```\n  •\n```\n\nMetodologia de aplicação de provas práticas;\n\n```\n  •\n```\nÉ possível escolher sua distribuição de preferência;\n\n```\n  •\n```\nNão depende de escolas autorizadas para execução das provas;\n\n```\n  •\n```\nFoi o primeiro centro certificador a fechar parceria com a Microsoft.\n\n\nSobre o programa de certificação da Linux Foundation, temos as seguintes certificações: *\nSysAdmin Linux Professional * Engineer Linux Professional\n\n\n15 2. Certificações Linux\n\n\nE por onde eu começo?\n\n```\n  •\n```\n\nCursos\n\n```\n  •\n```\nEstudos autodidatas\n\n```\n  •\n```\nSimulados\n\n```\n  •\n```\nFóruns\n\n```\n  •\n```\nListas de discussão"
    },
    {
        "chapter_id": "3",
        "title": "Capítulo 3",
        "content": "# **3**\n\n## História do Linux\n\nMuitos desconhecem a real história e origem do sistema operacional comumente chamado de\nLinux quando tem seu primeiro contato com o sistema. Antes de explicarmos o que é de fato\n\n- Linux, é preciso conhecer a origem e função do projeto GNU, assim como saber observar e\nmanipular o sistema operacional de uma forma mais técnica e detalhada.\n\n\nUm sistema operacional é formado por um conjunto de funções que, trabalhando em perfeita\nharmonia, manipulam o hardware através de uma interface de comunicação e assim oferecem\ntodos os recursos úteis para o seu gerenciamento. Conhecer detalhadamente as camadas que\nenvolvem um sistema operacional é um diferencial no aprendizado.\n\n\nO projeto GNU surgiu em meados de 1983, tendo como seu idealizador Richard Stallman, que\ntinha como objetivo criar um sistema operacional que fosse completamente livre e seguisse os\npadrões do Unix, que na época, cobrava licenças de alto custo. Cada ferramenta, função etc.,\ndeveria seguir apenas esta ideologia: ser livre.\n\n\nNesse contexto, quando fazemos referência à palavra livre, isso significa que é no sentido de\nliberdade ao código-fonte e forma de usar o software. Essa necessidade surgiu pelo fato de que\npraticamente todos os softwares da época estavam tomando o caminho oposto, ou seja, do\nsoftware proprietário. Nesse tipo de software, o usuário geralmente detém apenas a permissão\nde uso sobre o software, sem nenhum acesso ao código-fonte.\n\n\nO sistema GNU estava sendo desenvolvido por uma comunidade imensa, que seguiu os passos e as ideologias de Richard Stallman. Porém, com o tempo, o projeto foi ganhando tal\n\n\n16\n\n\n17 3. História do Linux\n\n\nconsistência e volume que necessitou urgentemente de um órgão para gerenciar todo o seu\ndesenvolvimento. Nasceu, então, a _Free Software Foundation_ (FSF).\n\n\nTodas as ferramentas desse sistema operacional estavam sendo preparadas do zero, como\n\n- editor de texto (Emacs), o ambiente gráfico (servidor X), compiladores (GCC, G++) e\ntambém um kernel (GNU/Hurd). Assim, um novo sistema operacional livre surgia, mas com\num detalhe muito importante: o desenvolvimento desse sistema livre deveria seguir os padrões\nde sistemas operacionais Unix, que é, sem dúvida, um padrão muito respeitado e conhecido\npor seu alto grau de segurança e confiabilidade.\n\n\nCertamente, muitos devem se perguntar o que houve com o sistema operacional GNU, que\nnão existe oficialmente. Para se ter um sistema operacional completo, é preciso ter todas\nas ferramentas e funções em perfeito funcionamento, como no desenvolvimento de um carro,\nonde cada peça terá sua função essencial e específica. Um dos grandes motivos do sistema\noperacional GNU não ter sido lançado foi pelo formato do desenvolvimento do seu kernel, o\nGNU/Hurd, que seguiu um modelo complexo, não se adequando ou obtendo a estabilidade\nnecessária para assumir a posição de um kernel maduro e confiável.\n\n\nEis que, no ano de 1991, o finlandês Linus Torvalds criou um kernel denominado Linux, o qual\npôde ser unido aos programas GNU. Dessa junção, nasceu o sistema GNU/Linux.\n\n\nCostumamos nos referir aos sistemas GNU/Linux apenas como sistemas Linux, denominação\nque não faz justiça aos desenvolvedores de software e ferramentas GNU, afinal, estamos nos\nreferindo apenas ao nome do kernel criado por Linus.\n\n\nOs sistemas operacionais que muitos usam atualmente, através das inúmeras distribuições\nexistentes e muito conhecidas, têm a contribuição das diversas ferramentas e utilitários desenvolvidos pelo projeto GNU no decorrer dos anos.\n\n\nGraças ao projeto GNU, o software livre se tornou uma ideologia respeitada e seguida mundialmente e, principalmente, defendida juridicamente, tornando-se o grande motivo para que pessoas em todo o mundo possam trocar informações e aprimorar sempre as tecnologias de\nsoftware desenvolvidas. Muitos outros projetos ainda são mantidos pelo projeto GNU, como\n\n- Gnash (Flash Player livre), o Coreboot (BIOS em formato de software livre), o cliente VOIP\nSkype com base em software livre etc.\n\n\nMais informações do projeto GNU podem ser encontradas em www.gnu.org.\n\n\n**Curiosidade** : GNU é um acrônimo recursivo para a frase _Gnu Is Not Unix_ (Gnu não é Unix),\nfazendo uma grande oposição ao formato proprietário que a maioria dos sistemas Unix seguia.\n\n\n18 3. História do Linux\n\n### **A origem do Linux**\n\n\nDepois de uma breve introdução sobre o projeto GNU, que tinha a intenção de criar um\nsistema operacional livre que seguisse os padrões do Unix, é hora de entender e conhecer, de\numa forma mais técnica, o que é de fato o Linux, e principalmente sua origem.\n\n\nPrimeiramente, é importante entender que, tecnicamente falando, o Linux não é um sistema\noperacional, mas sim um kernel, ou a grosso modo, o centro de execução do seu sistema\noperacional. Cada sistema operacional, independentemente da plataforma, possui o seu próprio\nkernel, com suas características peculiares.\n\n\nA história do Linux é um tanto aventureira, pois surgiu pelas mãos de um jovem estudante\nFinlandês chamado Linus Benedict Torvalds, que estudava Ciências da Computação na Universidade de Helsinki.\n\n\nLinus Torvalds, como é mais conhecido, começou o desenvolvimento do Linux a partir de\num projeto pessoal. Teve como base um sistema operacional Unix-like chamado Minix, que\nfoi desenvolvido por Andrew Tanenbaum em meados de 1987. O Minix era um sistema\noperacional básico, porém seguia os padrões do Unix e era muito utilizado no meio acadêmico\npara auxiliar no ensino de sistemas operacionais. Linus Torvalds iniciou seu projeto a partir do\nMinix e pretendia criar uma versão do Minix melhor do que o original.\n\n\nUnix-like é um termo utilizado para referenciar o padrão de sistemas operacionais\nUnix, onde temos um padrão robusto, seguro e estável. Basicamente, um sistema\nUnix-like tem o suporte fundamental aos recursos de multiusuário e multitarefa.\n\n\nFoi a partir dessa ideia que Linus Torvalds começou o desenvolvimento do seu projeto, conseguindo, na versão 0.01, melhorar o kernel do Minix, acrescentando suporte a recursos que\nestavam indisponíveis na versão anterior. Deu-se a esse sistema o nome Linux, que é uma\njunção de Linus com Unix, embora o próprio Linus tenha desgostado dessa ideia inicialmente,\nbatizando o sistema de Freax. Ari Lemmke, que trabalhava com Linus Torvalds, deu o nome\nLinux ao repositório dos arquivos do sistema Freax, sem consultar Linus que posteriormente\nacabou aceitando dar este nome ao novo sistema. Inicialmente, o desenvolvimento do kernel\nLinux foi simplesmente um passatempo para Linus Torvalds.\n\n\nO kernel Linux é um grande exemplo de software livre licenciado utilizando-se a GPL. A\niniciativa ganhou milhares de adoradores e conta atualmente com muitos desenvolvedores\nque trabalham de forma minuciosa, adicionando diariamente novas funções e corrigindo bugs,\natravés da criação de correções (patches). Em sua primeira versão, o kernel Linux já conseguia\ntrabalhar em conjunto com algumas ferramentas desenvolvidas pelo projeto GNU, como o\ncompilador GCC e o interpretador de comandos bash. A junção das milhares de ferramentas\n\n\n19 3. História do Linux\n\n\ndesenvolvidas pelo projeto GNU com o kernel Linux forma todas as camadas de preenchimento\npara que seja possível um sistema operacional completo. Mais informações sobre o kernel Linux\npodem ser encontradas em www.kernel.org."
    },
    {
        "chapter_id": "4",
        "title": "Capítulo 4",
        "content": "# **4**\n\n## Licenças Open Source\n\n### **Free Software Foundation**\n\nA _Free Software Foundation_ surgiu em 1985, com o propósito de organizar o projeto GNU em\num formato técnico e jurídico. A FSF é uma organização sem fins lucrativos, que se mantém\ncom a doação de empresas que apoiam a mesma causa: defender o software livre. Hoje, o\nfoco principal da FSF é manter a GPL ( _General Public License_ ), que é a licença utilizada para\ndefender juridicamente um software livre, assim como disseminar a ideologia de software livre\npelo mundo. Mais informações sobre a FSF podem ser encontradas em www.fsf.org.\n\n### **Software livre**\n\n\nAté o momento, o termo software livre, que foi idealizado por Richard Stallman e defendido\npela Free Software Foundation através da GPL, foi muito citado. Antes de entrar nos detalhes\ndo termo software livre, é preciso entender o que é essa ideia que moveu milhões de pessoas\npor todo o mundo.\n\n\nPrimeiramente, é preciso estar atento à tradução de free software, pois a palavra free pode\nter sentidos diferentes: livre e grátis. Quando nos referimos ao software livre, estamos nos\nreferindo à sua liberdade e não ao preço, ou seja, o usuário terá a liberdade de estudar,\nexecutar, alterar, melhorar, copiar e até mesmo distribuir um software livre.\n\n\nEssa ideia toda foi minuciosamente detalhada em quatro tipos de liberdades, conforme veremos\na seguir:\n\n\n20\n\n\n21 4. Licenças Open Source\n\n\n**Liberdade número 0** : é a liberdade de executar o software para qualquer propósito ou\nfinalidade;\n\n\n**Liberdade número 1** : é estudar o funcionamento do software, podendo fazer alterações e\nadaptá-las conforme a necessidade. Um pré-requisito para atingir essa liberdade é ter o acesso\ntotal ao código-fonte;\n\n\n**Liberdade número 2** : o usuário tem a liberdade de redistribuir cópias do software para quem\nquiser;\n\n\n**Liberdade número 3** : é a liberdade para modificar o programa e, então, disponibilizar as\nmelhorias para o público, de forma que toda a comunidade possa se beneficiar disso. O acesso\nao código-fonte é uma pré-condição para isso.\n\n\nA junção dessas quatro liberdades é a essência do software livre, no qual a ideia principal\né sempre prorrogar a liberdade de um software, de forma que um usuário jamais possa se\napoderar de um software livre e torná-lo algo como um software proprietário. Para tal função,\nexiste a GPL.\n\n### **GNU GPL (General Public License)**\n\n\nA GPL ( _General Public License_ ) teve sua primeira versão (GPLv1) lançada em janeiro de\n1989. Ela foi rapidamente substituída devido a correção de vulnerabilidades pela GPL versão 2\n(GPLv2), lançada em junho de 1991. Atualmente, também temos a GPL na versão 3 (GPLv3),\nque foi lançada oficialmente em junho de 2007 e permanece como referência até hoje.\n\n\nA GPL, que é uma importante ferramenta jurídica criada pela _Free Software Foundation_,\ntinha inicialmente, como principal função, defender a liberdade dos softwares desenvolvidos\npelo projeto GNU. Posteriormente, foi utilizada e empregada por centenas de outros softwares\nenvolvidos em projetos de terceiros e particulares por todo o mundo.\n\n\nA _Licença Pública Geral_ segue, desde a sua primeira versão, as quatro liberdades citadas anteriormente, sendo também sua intenção poder defender o software livre de forma prorrogada.\nO documento oficial da GPL, válido oficialmente como ferramenta de proteção ao software\nlivre, existe somente em inglês.\n\n\nOutras licenças também foram criadas com a finalidade de manter a defesa da liberdade do\ncódigo aberto, do conhecimento e da informação, como foi iniciado pela GPL. Algumas delas\nestão na tabela a seguir:\n\n\n**Licença** **Site**\n\n\n  - GFDL (GNU Free Documentation License) www.gnu.org/copyleft/fdl.html\n\n\n22 4. Licenças Open Source\n\n\n**Licença** **Site**\n\n\n    - OPL (Open Publication License) www.opencontent.org/openpub/\n\n      - CC (Creative Commons) creativecommons.org/about/licenses\n\n    - BSD (Berkley Software Distribution) www.freebsd.org/copyright/license.html\n\n      - SPL (Sun Public License) java.sun.com/spl.html\n\n\nPara mais informações sobre as versões da GPL, acessar http://www.gnu.org/licenses/licenses.html."
    },
    {
        "chapter_id": "5",
        "title": "Capítulo 5",
        "content": "# **5**\n\n## Evolução do Linux: distribuições\n\nCom a junção das ferramentas GNU e o kernel Linux, temos tecnicamente um sistema operacional GNU/Linux. Em suas primeiras versões, instalar um sistema GNU/Linux era extremamente complexo, pois era necessário praticamente instalar e compilar manualmente quase todas\nas ferramentas, incluindo o próprio kernel. Ou seja, o GNU/Linux era geralmente utilizado por\nusuários avançados.\n\n\nFoi a partir dessa dificuldade que surgiram as primeiras distribuições GNU/Linux – também\nchamadas de distros –, que tinham a finalidade de facilitar a instalação do sistema, disponibilizando todas as ferramentas necessárias, com um kernel Linux e um instalador para automatizar o processo de instalação. Tudo isso era disponibilizado através de um CD, disquete ou\noutro tipo de mídia.\n\n\nUma distribuição Linux é um pacote que consiste em um kernel Linux, mais uma seleção\nde aplicativos mantidos por uma empresa ou comunidade de usuários. O objetivo de uma\ndistribuição é otimizar o kernel e os aplicativos que são executados no sistema operacional\npara um determinado tipo de uso ou grupo de usuários. As distribuições frequentemente\nincluem ferramentas próprias para a instalação de software e administração do sistema. Por\nessa razão, certas distribuições são usadas principalmente em ambientes desktop, por serem\nmais fáceis de usar, enquanto outras são mais comumente instaladas em servidores para usar\nos recursos disponíveis da maneira mais eficiente possível.\n\n\nHoje existe uma quantidade imensa de distribuições disponíveis para instalação, com praticamente todos os níveis de dificuldade e usos específicos.\n\n\n23\n\n\n24 5. Evolução do Linux: distribuições\n\n\nEm 1993, Patrick Volkerding reuniu o kernel Linux e diversos aplicativos, dando origem à\ndistribuição denominada Slackware, tida como a primeira a ser disponibilizada de forma pública,\nem CDs já pré-compilados e prontos pra instalação por qualquer usuário em qualquer tipo de\ncomputador.\n\n\nA maioria das distribuições existentes hoje em dia são ramificações da Slackware e de outras\ntrês distribuições: Debian, Red Hat e SUSE. As mais antigas e tradicionais são Slackware e\nDebian, que surgiram em meados de 1993.\n\n\nNo site DistroWatch.Com (distrowatch.com), é possível conferir a lista de distribuições existentes, bem como notícias e últimas atualizações de cada uma delas. O site também disponibiliza links para aquisição das distribuições.\n\n### **Distribuições livres e corporativas**\n\n\nA maioria das distribuições é mantida por comunidades de colaboradores localizados em todo\n\n- mundo e por corporações. Dada essa característica, as distribuições podem ser divididas em\nduas categorias: livres e corporativas. O primeiro tipo é disponibilizado por comunidades de\ncolaboradores que não visam absolutamente nenhum lucro sobre suas distribuições, como é o\ncaso do Slackware, Debian, Knoppix, Gentoo e CentOS.\n\n\nDentro das distribuições livres, subdividem-se ainda as convencionais, tradicionalmente distribuídas em algum tipo de mídia para instalação em disco rígido, e as distribuições Live,\ncuja execução se dá a partir da própria mídia, sem instalação no HD e, portanto, sem risco\nao sistema operacional original da máquina no qual está sendo executada. Quase todos os\ncomponentes do sistema já vêm previamente configurados numa distribuição Live, o que a\ntorna conveniente e fácil de usar. A Knoppix é um exemplo bem conhecido de distribuição\nLive, e dele surgiram o Kurumin e o Kalango, já traduzidos para o português e adaptados à\nnossa realidade.\n\n\nJá as distribuições corporativas, como Ubuntu, Suse, Red Hat e Mandriva, são administradas\npor empresas que cobram pelo suporte prestado. É importante notar que, embora um custo\nesteja envolvido, isso não contradiz os princípios da licença GPL, pois a liberdade de software\né mantida. Qualquer usuário tem acesso ao código-fonte das distribuições corporativas, de\nforma que, o que é vendido não é o produto, mas uma prestação de serviço de assistência e\nsuporte caso estes se façam necessários.\n\n### **Distribuições from scratch e derivadas**\n\n\nAs distribuições também podem ser categorizadas de acordo com a maneira como são desenvolvidas. Assim, são classificadas como from scratch (do zero) ou derivadas de alguma outra\n\n\n25 5. Evolução do Linux: distribuições\n\n\ndistribuição.\n\n\nA diferença básica entre os dois tipos é que as distribuições from scratch não derivam de\nnenhuma já existente, sendo todas as suas características desenvolvidas específica e exclusivamente para elas, como é o caso da Debian, Red Hat, Slackware e Gentoo, enquanto as\nderivadas baseiam-se em alguma distribuição anterior, recebendo ajustes e visando um objetivo funcional definido. Exemplos desse tipo são os mencionados Kubuntu e Kurumin, além\nde Ubuntu, DreamLinux, BrDesktop e Slax.\n\n\nMuitas distribuições independentes foram lançadas ao longo dos anos. Algumas delas se baseiam em Red Hat ou Ubuntu, outras são projetadas para aprimorar uma propriedade específica\nde um sistema ou hardware. Existem distribuições construídas com funcionalidades específicas, como o QubesOS, um ambiente de desktop extremamente seguro, ou o Kali Linux, que\noferece um ambiente para explorar vulnerabilidades de software e é usado principalmente para\ntestes de invasão. Recentemente, diversas distribuições Linux minúsculas foram projetadas\npara serem executadas especificamente em containers Linux, como o Docker. Existem também distribuições construídas especificamente para componentes de sistemas embarcados e\naté mesmo para dispositivos inteligentes.\n\n\n**Red Hat Enterprise Linux**\n\n\nA distribuição Red Hat Linux, criada em 1993, é pioneira em distribuições GNU/Linux corporativas. Tem grande aceitação por parte das empresas pelo fato de oferecer suporte técnico\ne grande compatibilidade com as tecnologias mais utilizadas, tendo conquistado no mercado\ncorporativo o posto de uma das maiores produtoras de soluções open source do mercado. Sua\ninterface gráfica padrão é a GNOME e utiliza o sistema de pacotes RPM ( _RedHat Package_\n_Manager_ ) para a instalação de aplicativos.\n\n\nDerivada da Red Hat Linux, a Red Hat Enterprise Linux é uma versão corporativa de distribuição original. Outro projeto relacionado é o Fedora Project, projeto patrocinado pela Red\nHat, cuja proposta é ser uma distribuição para a comunidade. O CentOS é uma derivação\nidêntica ao Red Hat Enterprise Linux até sua versão 8. Veremos mais detalhes sobre isso em\ntópico posterior.\n\n\nVale ressaltar que a Red Hat possui algumas das mais conceituadas certificações Linux, focadas\nexclusivamente em seus produtos.\n\n\nPara mais informações sobre essa distribuição, acessar https://www.redhat.com.\n\n\n**CentOS**\n\n\nO CentOS, abreviação de _Community Enterprise Operating System_, é uma distribuição Linux\nde classe corporativa derivada de códigos fonte gratuitamente distribuídos pela Red Hat En\n\n26 5. Evolução do Linux: distribuições\n\n\nterprise Linux e mantida pelo CentOS Project. Esta distribuição sempre foi uma alternativa\npara empresas que não desejam pagar por uma distribuição fechada, mas esse cenário pode\nmudar com o anúncio da desativação do projeto CentOS em 2021 e a mudança de foco para\n\n- projeto CentOS Stream, onde teremos uma distribuição para mostrar o que está por vir\nno Red Hat Linux. A numeração das versões sempre foi baseada na numeração do Red Hat\nEnterprise Linux. Por exemplo, o CentOS 7 é baseado no Red Hat Enterprise Linux 7, mas\ncom a chegada do CentOS Upstream isso mudará, pois será uma distribuição do tipo _rolling_\n_release_ (lançamento contínuo) sem lançamento de versões finais.\n\n\nEmbora o CentOS seja bem visado para seu uso em servidores devido a sua estabilidade e\nrobustez, ele não é um sistema exclusivo de servidores. Tem essa fama devido ao seu foco em\nrecursos estáveis (semelhantes ao que o Debian GNU/Linux faz) e as aplicações são focadas\nem estações de trabalho e redes por padrão. Ele pode ser usado para uso comum, porém,\né necessário incluir nele os repositórios adicionais que não vem ativos por padrão. Os mais\ncomuns são: RPMFusion e EPEL.\n\n\nA partir do CentOS 5, cada versão é suportada por 10 anos (por meio de atualizações de\nsegurança, assim como as versões anteriores eram suportadas por 7 anos). Uma nova versão\ndo CentOS é lançada aproximadamente a cada 2 anos e cada versão do CentOS é atualizada regularmente aproximadamente a cada 6 meses, para oferecer suporte a hardware mais\nrecente. Isso resulta em um ambiente seguro, de baixa manutenção, confiável, previsível e\nreproduzível. Como o RHEL exige que os usuários comprem uma licença, alguns preferem\noptar pelo CentOS, que fornece atualizações gratuitamente. Uma das desvantagens é que os\nlançamentos do CentOS sempre demoram um pouco mais do que os lançamentos do RHEL\npara serem disponibilizados enquanto a comunidade testa os pacotes e faz alterações de marca\ne similares.\n\n\nEste ciclo está em processo de mudança, devido ao foco no novo projeto CentOS\nStream.\n\n\nFonte: https://wiki.centos.org/About\n\n\nO CentOS Stream servirá como o ramo _upstream_ (desenvolvimento) do Red Hat\nEnterprise Linux.\n\n\nO CentOS 8 terá seu suporte encerrado em 31 de Dezembro de 2021.\n\n\n27 5. Evolução do Linux: distribuições\n\n\nO CentOS 7 terá seu suporte encerrado em 30 de Junho de 2024, mantendo assim o\nciclo de suporte RHEL 7.\n\n\nA Red hat orienta aos usuários do CentOS 8 a realizar a mudança para o Centos Upstream\nquando o suporte acabar:\n\n\n“ _Quando o CentOS Linux 8 (a reconstrução do RHEL8) terminar, sua melhor opção_\n_será migrar para o CentOS Stream 8, que é um pequeno delta do CentOS Linux 8 e_\n_tem atualizações regulares como as versões tradicionais do CentOS Linux. Se você_\n_estiver usando o CentOS Linux 8 em um ambiente de produção e estiver preocupado_\n_com o fato de o CentOS Stream não atender às suas necessidades, recomendamos_\n_que você entre em contato com a Red Hat sobre as opções disponíveis._ ”\n\n\nPara mais informações sobre essa distribuição, acessar www.centos.org.\n\n\n**Oracle Linux**\n\n\nA Oracle Linux é uma distribuição Linux empacotada e distribuída gratuitamente pela Oracle,\ndisponível parcialmente sob a GNU General Public License desde o final de 2006. É compilada\na partir do código-fonte do Red Hat Enterprise Linux (RHEL), substituindo a marca Red Hat\npela Oracle.\n\n\nOferece acesso a algumas das inovações mais avançadas do Linux, como Ksplice (extensão\ndo Kernel Linux que permite que patches de segurança sejam aplicados a um kernel em\nexecução sem a necessidade de reinicializações), e DTrace (estrutura de rastreamento dinâmico\nabrangente criada originalmente pela Sun Microsystems para solucionar problemas de kernel e\nde aplicativo em sistemas de produção em tempo real).\n\n\nPara mais informações sobre essa distribuição, acessar www.oracle.com/linux.\n\n\n**Slackware**\n\n\nCriada por Patrick Volkerding, a distribuição livre Slackware Linux foi a primeira a ser distribuída em CD e é um sistema Unix-like multitarefa completo de 32-bits. Utiliza o sistema\nde pacotes tgz, orientado por menus, e sua interface padrão é a KDE. É compatível com 486\nsistemas, incluindo os servidores x86 mais modernos, possui extensa documentação online e\num programa de instalação fácil de usar.\n\n\nA instalação completa da Slackware proporciona ao usuário o Sistema X, os ambientes de\ndesenvolvimentos C/C++, o Perl, um servidor de notícias, um servidor de e-mail, um servidor\n\n\n28 5. Evolução do Linux: distribuições\n\n\nweb e um servidor FTP. Possui ainda o _GNU Image Manipulation Program_, o navegador\nMozilla Firefox, utilitários de rede, além de muitos outros programas.\n\n\nPara mais informações sobre essa distribuição, acessar www.slackware.com.\n\n\n**Debian GNU/Linux**\n\n\nCom interface padrão Xfce, a distribuição livre Debian é atualmente uma das maiores distribuições e uma das principais bases para outras distribuições derivadas. Faz uso do sistema\nde pacotes DEB – Debian Package e é executada em quase todos os computadores pessoais,\ninclusive os mais antigos, sendo que cada nova versão normalmente fica compatível com mais\nmáquinas.\n\n\nA Debian, criada em 1993 por Ian Murdock, foi uma das primeiras distribuições criadas, com o\nintuito de ser desenvolvida abertamente, seguindo os moldes do Linux em si. Embora possa ser\nbaixada virtualmente e instalada normalmente com uma conexão rápida, é tradicionalmente\ndistribuída para instalação em CDs, que podem ser comprados pelo preço somente da mídia.\n\n\nPara mais informações sobre essa distribuição, acessar www.debian.org.\n\n\n**Ubuntu**\n\n\nBaseado no Debian, o Ubuntu, cujo nome significa “ _Humanidade para os outros_ ” ou “ _Sou o_\n_que sou pelo que nós somos_ ” em africano, conta com diversas ferramentas, como servidores\nweb, ferramentas de programação, processador de texto e leitor de e-mails. Distribuído de\nforma convencional e Live, o Ubuntu é usado em laptops, desktop e servidores, e esses dois\núltimos contam com atualizações de segurança gratuitas por, no mínimo, 18 meses.\n\n\nO Ubuntu, que utiliza o sistema de pacotes DEB, serviu de derivação para outras distribuições,\ncomo Kubuntu, Xubuntu e Lubuntu, só para citar algumas. Sua interface padrão é a GNOME\nou KDE. Esta última é adotada pela distribuição Kubuntu.\n\n\nAs versões LTS ou ‘ _Long Term Support_ ’ são publicadas a cada dois anos, no mês de abril. As\nversões LTS são as versões de ‘nível empresarial’ do Ubuntu e são as mais utilizadas. Estima-se\nque 95% de todas as instalações do Ubuntu sejam lançamentos LTS.\n\n\nA cada seis meses entre as versões LTS, a Canonical publica uma versão provisória do Ubuntu,\nsendo a versão 20.10 o exemplo mais recente. Essas são versões de qualidade de produção\ne são suportadas por 9 meses, com tempo suficiente fornecido para os usuários atualizarem,\nmas essas versões não recebem o compromisso de longo prazo recebido das versões LTS.\n\n\n29 5. Evolução do Linux: distribuições\n\n\nOs lançamentos provisórios apresentam novos recursos de projetos de código aberto da Canonical e upstream, e servem como um campo de testes para esses novos recursos. Muitos desenvolvedores executam lançamentos provisórios porque fornecem compiladores mais novos ou\nacesso a kernels e bibliotecas mais recentes e são frequentemente usados em processos de\nDevOps rápidos, como pipelines de CI/CD, onde a vida útil de um artefato é provavelmente\nmenor do que o período de suporte do lançamento provisório. Versões provisórias recebem\nmanutenção de segurança total para a árvore principal ( _main_ ) do projeto durante sua vida útil.\n\n\nPara mais informações sobre essa distribuição, acessar www.ubuntu.com.\n\n\n**Linux Mint**\n\n\nMint é uma distribuição derivada e compatível com o Ubuntu. Possui duas versões: uma\nbaseada em Ubuntu (com o qual é totalmente compatível e partilha dos mesmos repositórios)\ne outra versão baseada em Debian. Suporta muitos idiomas, incluindo a língua portuguesa e\nutiliza o Cinnamon como seu principal ambiente de desktop. Esforça-se para ser um “sistema\noperacional moderno, elegante e confortável, além de poderoso e fácil de usar” e possui suporte\nmultimídia pronto para o uso, incluindo alguns softwares proprietários e vem com uma variedade\nde aplicativos gratuitos e de código aberto. O Linux Mint diferencia-se do Ubuntu e do Debian\npor incluir drivers e codecs proprietários por padrão e por alguns recursos que permitem fazer\natravés da interface gráfica (GUI – _Graphical User Interface_ ) configurações que em ambos\nos sistemas são feitas através do modo texto (CLI – _Command Line Interface_ ). Utiliza por\npadrão o desktop Cinnamon, um derivado do GNOME, com um menu no painel inferior junto\nà barra de tarefas (o MintMenu), similar ao menu do KDE ou o menu “Iniciar” do Windows.\nO propósito da distribuição é providenciar um sistema Linux que funcione “out-of-the-box”,\nisto é, que esteja pronto para uso assim que terminada sua instalação.\n\n\n30 5. Evolução do Linux: distribuições\n\n\nPara mais informações sobre essa distribuição, acessar www.linuxmint.com.\n\n\n**Fedora**\n\n\nOutro sistema operacional baseado em Linux é o Fedora, de distribuição livre. Tem como\ninterface padrão a GNOME e o gerenciamento de pacotes é feito de forma padrão pelo gerenciador de pacotes YUM. O YUM automaticamente baixa e gerencia a instalação do que for\nexigido pelo sistema, administrando pacotes instalados, atualizando ou removendo pacotes\ndesnecessários.\n\n\nPatrocinado pela Red Hat, o Fedora tem uma média de lançamento de versões novas a cada\nseis meses pelo Fedora Project, que é uma parceria formada por membros da comunidade\nde Software Livre. Diversas aplicações estão disponíveis para essa distribuição, como players\nde vídeo e áudio, que é o caso do MPlayer e do Amarok e de pacotes de ferramentas para\nescritório como o OpenOffice, além de uma coleção de jogos.\n\n\nPara mais informações sobre essa distribuição, acessar fedoraproject.org.\n\n\n**Arch Linux**\n\n\nUma distribuição no estilo _rolling release_ (lançamento contínuo) com foco em usuários avançados e mantida por uma comunidade de voluntários. Com o sistema rolling release, os usuários\npodem ter acesso às últimas atualizações estáveis. Por exemplo, enquanto um usuário de\nArch tem acesso imediato a última versão do GNOME, um de Ubuntu precisa esperar que\na Canonical libere, na próxima versão do sistema operacional, essa atualização. As imagens\nde instalação lançadas pela equipe do Arch são apenas capturas instantâneas de imagens de\ndisco atualizadas dos principais componentes do sistema.\n\n\nPara mais informações sobre essa distribuição, acessar archlinux.org.\n\n\n**Manjaro Linux**\n\n\nUma distribuição derivada do Arch Linux que inclui uma instalação gráfica e outras ferramentas\npara facilitar seu uso por usuários com menos conhecimento do Linux. O Manjaro Linux, ou\napenas Manjaro (pronunciado “man-djá-ro” como em Kilimanjaro), é uma distribuição Linux\ncom o ambiente gráfico padrão Xfce. Um sistema operacional de software livre, principalmente voltada para computadores pessoais destinadas a facilidade de uso. Como sua base de\ninspiração, o Arch Linux, o Manjaro usa um modelo rolling release. A distribuição tem como\nobjetivo ser uma nova distribuição amigável ao usuário ( _user friendly_ ), mantendo a poderosa\nbase Arch, mais notavelmente o gerenciador de pacotes Pacman e a compatibilidade com o\nAUR (Repositório dos Usuários do Arch).\n\n\nPara mais informações sobre essa distribuição, acessar manjaro.org.\n\n\n31 5. Evolução do Linux: distribuições\n\n\n**SUSE**\n\n\nUma das principais concorrentes da Red Hat, a distribuição corporativa SUSE foi adquirida\npela empresa Novell em 2003. Atua no mercado corporativo oferecendo soluções para servidores e desktop. Sua interface padrão é a GNOME e adota o RPM como gerenciador de\npacotes, incorporando suas próprias variações a esse sistema. A fim de sustentar uma alta\ncompatibilidade com produtos de outras empresas, a SUSE cultiva muitas parcerias.\n\n\nPara mais informações sobre essa distribuição, acessar https://www.suse.com/.\n\n\n**OpenSUSE**\n\n\nCom a interface padrão GNOME ou KDE e o sistema de pacotes RPM, a distribuição OpenSUSE é uma distribuição livre, patrocinada pela Novell e disponibilizada gratuitamente pelo\nopenSUSE.org, visando a disseminar o uso do Linux. Tanto o OpenSUSE quanto as outras\ndistribuições da SUSE Linux Enterprise têm como ferramenta de instalação e configuração o\nYaST.\n\n\nPara mais informações sobre essa distribuição, acessar www.opensuse.org.\n\n\n**Knoppix**\n\n\nDistribuição do tipo Live, a Knoppix é executada a partir de um CD ou DVD, e pode se\nmostrar produtiva para desktops, sistemas educacionais, sistemas de recuperação ou ainda\nadaptada para versões demonstrativa de softwares. Consiste na plataforma GNU/Linux, com\ndetecção automática dos dispositivos de hardware e suporte para vários periféricos, incluindo\ndispositivos USB e placas gráficas.\n\n\nSeu sistema de pacotes é o DEB e tem como interface padrão a KDE. Em razão de sua\nferramenta de remasterização, a Knoppix contribuiu significantemente para que as distribuições\ndo tipo Live ganhassem popularidade. Essa ferramenta facilitou a tarefa de produzir novas\ndistribuições.\n\n\nPara mais informações sobre essa distribuição, acessar www.knoppix.org.\n\n\n**Gentoo**\n\n\nGentoo é o que se chama de metadistribuição, devido à sua quase ilimitada adaptabilidade.\nNão só sua interface padrão fica à escolha do usuário, como o sistema pode ser otimizado\ne personalizado para praticamente qualquer aplicativo ou necessidade, provando-se eficiente\ncomo servidor seguro, workstation de desenvolvimento, desktop profissional, sistema de jogos,\ne solução embutida, para citar alguns exemplos.\n\n\n32 5. Evolução do Linux: distribuições\n\n\nO sistema operacional é baseado no Linux ou no FreeBSD e seu sistema de pacotes é o emerge,\nque interage com o Portage, um sistema de distribuição de software, construção de pacotes e\ninstalação. Mantido por mais de 300 desenvolvedores e milhares de usuários e distribuído de\nforma Live, o Gentoo conta com ferramentas de documentação, infraestrutura, engenharia de\nlançamento, portagem de software e garantia de qualidade, entre outras.\n\n\nPara mais informações sobre essa distribuição, acessar www.gentoo.org.\n\n### **Ciclo de vida de algumas distribuições Linux**\n\n\n**Debian GNU/Linux**\n\n\nO Debian sempre tem pelo menos três versões em manutenção ativa: estável (stable), testing\ne instável (unstable).\n\n\n`•` **Estável (stable)** : a distribuição em sua versão estável (stable) contém a última versão\noficialmente lançada do Debian. Esta é a versão de produção do Debian, a que nós\nprimeiramente recomendamos que seja usada. A atual distribuição estável (stable) do\nDebian é a versão 10, codinome buster. Ela foi inicialmente lançada como versão 10 em\n6 de julho de 2019 e sua última atualização, a versão 10.3, foi lançada em 8 de fevereiro\nde 2020.\n\n`•` **testing** : a distribuição na versão testing contém pacotes que ainda não foram aceitos\nna versão estável (stable), mas que estão na fila para tal. A principal vantagem de usar\nesta distribuição é que ela possui versões mais recentes de software. A atual distribuição\ntesting é a _bullseye_ .\n\n`•` **Instável (unstable)** : a distribuição na versão instável (unstable) é onde o desenvolvimento ativo do Debian ocorre. Geralmente, esta distribuição é utilizada por desenvolvedores e por aqueles que gostam de viver no limite. A distribuição instável (unstable) é\nsempre chamada de _sid_ .\n\n\nFonte para consulta: https://www.debian.org/releases/index.pt.html\n\n### **Evolução do Linux: dispositivos embarcados**\n\n\nOs sistemas embarcados são uma combinação de hardware e software projetados para cumprir\numa função específica dentro de um sistema maior. Normalmente fazem parte de outros\ndispositivos e ajudam a controlá-los. Podem ser encontrados em aplicações automotivas,\nmédicas e até militares. Devido a essa ampla variedade de aplicações, Uma variedade de\nsistemas operacionais baseados no kernel do Linux foi desenvolvida para uso em sistemas\nembarcados. Uma parte significativa dos dispositivos inteligentes usa um sistema operacional\nbaseado no kernel do Linux.\n\n\n33 5. Evolução do Linux: distribuições\n\n\nAssim, em sistemas embarcados temos software embarcado, cujo objetivo é acessar o hardware e torná-lo utilizável. Dentre as principais vantagens do Linux sobre qualquer software\nembarcado proprietário estão a compatibilidade entre plataformas de diferentes fornecedores,\ndesenvolvimento, suporte e ausência de taxas de licença. Dois dos mais populares projetos de\nsoftware embarcado são o Android, usado principalmente em telefones celulares por diferentes\nfabricantes, e o Raspbian, que é usado principalmente no Raspberry Pi.\n\n\nO Linux se tornou tão popular como uma plataforma de software para a Internet das Coisas\n(IoT), que você pode encontrar não apenas uma, mas muitas distribuições Linux para utilizar\nem seus projetos. Distribuições populares do Linux para IoT:\n\n\n`•` **AndroidThings** : sistema operacional baseado em Android com suporte para APIs do\nAndroid e serviços do Google.\n\n`•` **Debian Tinker** : Debian para sistemas embarcados.\n\n`•` **OpenWrt** : distribuição baseada em Linux para dispositivos embarcados (usados principalmente em dispositivos como roteadores sem fio).\n\n`•` **Raspbian** : Raspbian é um derivado do sistema operacional Debian Linux que funciona\nno hardware Raspberry Pi (inclui mais de 35K pacotes).\n\n`•` **Tizen** : a pilha de Linux Embarcado da Samsung que alimenta grande parte dos dispositivos de consumidor e IoT da Samsung.\n\n`•` **Ubuntu Core** : o Ubuntu Core é uma versão incorporada do Ubuntu que é executada\nem sistemas com recursos mínimos (como o Raspberry Pi).\n\n`•` **Yocto** : o Yocto não é por si só uma distribuição, mas sim um projeto de código aberto\nque ajuda a criar distribuições personalizadas do Linux para sistemas embarcados e IoT."
    },
    {
        "chapter_id": "6",
        "title": "Capítulo 6",
        "content": "# **6**\n\n## Conhecendo o Linux\n\nOs sistemas GNU/Linux herdaram muitas características do padrão Unix, o que refletirá na\nmaneira como executaremos os comandos a partir do interpretador de comandos. O sistema\noperacional MAC OS X, da Apple, por ser Unix-like, também herda tais características.\n\n\n`•` **Representação por arquivos** : esta é uma herança fundamental do sistema Unix, em\nque tudo que estiver presente no sistema será representado por um arquivo. Para tanto,\nteremos várias classificações para tipos de arquivos, que representarão dispositivos de\narmazenamento de dados, memória física, portas seriais ou paralelas, arquivos especiais,\narquivos de texto comuns, binários e até mesmo diretórios. É importante dizer que um\ndiretório também é um arquivo, um arquivo especial que aponta para outros arquivos\ne subdiretórios presentes dentro do sistema. No momento de gerenciar o sistema, é\nimportante saber lidar com todos esses tipos de arquivos e tomar as devidas precauções\nna hora de manipulá-los.\n\n`•` **Aspecto case-sensitive** : uma característica forte em sistemas Unix-like é a presença da\ncaracterística case-sensitive, em que letras maiúsculas serão completamente diferentes\nde letras minúsculas e vice-versa. No início, quando não se tem prática e costume\ncom essa característica, é um tanto desconfortável se acostumar, mas depois, com o\ndomínio, ela é útil e prática. A funcionalidade case-sensitive estará presente no sistema\natravés de nomes de arquivos, diretórios, comandos etc. Por exemplo, o comando LS é\ncompletamente diferente de ls.\n\n`•` **Permissão para executar arquivos** : em sistemas Unix-like, para que um arquivo possa\nser executado, inclusive pelo administrador do sistema, deve existir, obrigatoriamente,\npermissões de execução. Esse arquivo pode ser um arquivo binário de um comando\n\n\n34\n\n\n35 6. Conhecendo o Linux\n\n\nqualquer, um shell script etc. A permissão de execução protege o sistema contra arquivos\nauto-executáveis e faz com que os sistemas Unix-like sejam praticamente imunes a vírus\nou arquivos com funções mal-intencionadas.\n\n`•` **Arquivos e diretórios ocultos** : por padrão, a forma utilizada para identificar arquivos\nou diretórios ocultos no sistema é iniciar seus respectivos nomes por um ponto (.).\nUma vez que na linha de comandos não há como utilizar efeitos como os usados nos\nambientes gráficos, para visualizar tais arquivos ou diretórios ocultos, basta utilizar uma\nsimples opção com o comando de visualização ls, que será abordado posteriormente\nneste treinamento.\n\n`•` **Divisão em camadas** : o sistema é todo dividido e trabalhado em camadas, não sendo\nnecessária a execução obrigatória de um ambiente gráfico, por exemplo. Teremos o\nkernel como o centro de execução do nosso sistema, que controlará todo o hardware\ne fará a interface de controle e gerenciamento dos usuários, aplicações e processos em\nexecução.\n\n`•` **Superusuário (root)** : o superusuário root é, por padrão, o único usuário com permissões completas de administração e gerenciamento do sistema. Sua utilização deve ser\nrestrita e extremamente cautelosa, exatamente pela liberdade que possui ao executar\nqualquer tipo de tarefa, como excluir um diretório importante, por exemplo. O login do\nsuperusuário é root e o que define esse login como superusuário não é simplesmente o\nnome root, mas sim a UID ( _User Identification_ ), que é o número de identificação que\ncada usuário terá no sistema. O superusuário possui UID de número 0 (zero).\n\n`•` **Aspecto multitarefa / multiusuário** : uma característica herdada dos primórdios Unix\né poder executar várias tarefas ao mesmo tempo, com vários usuários trabalhando simultaneamente no sistema.\n\n### **Principais aplicações desktop Open-Source**\n\n\n`•` **Firefox** : um dos navegadores mais populares do mundo e utilizado por milhões de\npessoas está presente em ambas as plataformas, a experiência de usar o Mozilla Firefox\nno Windows e no Linux é basicamente a mesma, então em uma possível migração isso\nnão fará muita diferença. Claro que o Firefox não é o único navegador multiplataforma,\ntemos outras opções equivalentes como Chrome, Vivaldi, Opera entre outros.\n\n`•` **Thunderbird** : com o Thunderbird você baixa ou apenas acessa seus emails do Zimbra,\nGmail, Hotmail, Yahoo, iG, UOL, Oi Mail, iBest, Terra, BOL ou qualquer outro provedor com suporte a SMTP/POP3/IMAP. O Thunderbird permite que você adicione novo\nrecursos a medida que você precisar através de extensões. As extensões são ferramentas\npoderosas que auxiliam você a criar um cliente de e-mail de acordo com suas necessidades. O Thunderbird oferece recursos necessários a empresas, tais como S/MIME,\nassinaturas digitais, criptografia de mensagens, suporte a certificados e dispositivos de\nsegurança.\n\n`•` **GIMP** : é um programa de código aberto voltado principalmente para criação e edição\n\n\n36 6. Conhecendo o Linux\n\n\nde imagens e em menor escala também para desenho vetorial. O GIMP foi criado\npela comunidade como uma alternativa livre ao Adobe Photoshop. Foi um projeto\nuniversitário que amadureceu bastante e hoje alcança expressiva popularidade, sendo\nutilizado por hobbistas e profissionais.\n\n`•` **Inkscape** : é um software livre para editoração eletrônica de imagens e documentos\nvetoriais. Utiliza o método vetorial, ou seja, gera imagens a partir de um caminho de\npontos definindo suas coordenadas, de forma transparente ao usuário. Imagens vetoriais\ntêm maior aplicação em desenho técnico ou artístico e são, geralmente, mais leves e\nnão perdem a qualidade ao sofrer transformações, como redimensionamento ou giro.\nO Inkscape trabalha nativamente com o formato SVG (Scalable Vectorial Graphics),\num formato aberto de imagens vetoriais, nomeadamente, uma subdefinição (DTD) da\nlinguagem XML definido pela W3C. O aplicativo também exporta para o popular formato\nda Internet PNG e importa vários formatos vectoriais ou bitmap, como por exemplo:\nTIFF, GIF, JPG, AI, PDF, PS, entre outros.\n\n`•` **Kdenlive** : KDE Non-Linear Video Editor é um editor de vídeo open-source baseado\nno framework MLT e KDE. O projeto foi iniciado por Jason Wood em 2002, e hoje\né mantido por um pequeno time de desenvolvedores. Com o lançamento do Kdenlive\n15.04.0 passou a ser oficialmente parte do projeto oficial do KDE. Pacotes do Kdenlive\nestão livremente disponíveis para Linux, FreeBSD e Mac OS X sob os termos da GNU\nGeneral Public License versão 2 ou posterior.\n\n`•` **Virtualbox** : é um software de virtualização desenvolvido pela empresa Innotek depois\ncomprado pela Sun Microsystems que posteriormente foi comprada pela Oracle que,\ncomo o VMware Workstation, visa criar ambientes para instalação de sistemas distintos.\nEle permite a instalação e utilização de um sistema operacional dentro de outro, assim como seus respectivos softwares, como dois ou mais computadores independentes,\nmas compartilhando fisicamente o mesmo hardware. O VirtualBox pode ser instalado\nem vários sistemas operacionais hospedeiros, incluindo: Linux, MacOS e Windows. O\nVirtualBox pode ser usado tanto por usuários comuns, quanto por desenvolvedores de\nsistemas ou profissionais de TI.\n\n`•` **LibreOffice** : é uma suíte de aplicativos livre para escritório disponível para Windows,\nUnix, Solaris, Linux e Mac OS X. A suíte utiliza o formato OpenDocument (ODF –\n_OpenDocument Format_ ) – formato homologado como ISO/IEC 26300 e NBR ISO/IEC\n26300 – e é também compatível com os formatos do Microsoft Office, além de outros\nformatos legados. Alguns deles não são suportados pelas versões mais recentes do Microsoft Office, mas ainda podem ser abertos pelo LibreOffice. O LibreOffice é composto\npelos seguintes aplicativos:\n\n**– Writer**    - Editor de Texto;\n\n**– Calc**    - Planilha;\n\n**– Impress**    - Apresentações;\n\n**– Draw**    - Desenho Vetorial;\n\n**– Math**    - Fórmulas matemáticas;\n\n\n37 6. Conhecendo o Linux\n\n\n**– Base**    - Banco de Dados;\n\n`•` **VLC** : é um software de media player portátil gratuito e de código aberto, multiplataforma e também um servidor de mídia de streaming desenvolvido pelo projeto\nVideoLAN. O VLC está disponível para sistemas operacionais de desktop e plataformas\nmóveis, como Android e iOS. O VLC também está disponível em plataformas de distribuição digital, como a App Store da Apple ou na Google Play. O VLC suporta muitos\nmétodos de compactação de áudio e vídeo e formatos de arquivo, incluindo DVD-Video,\nCD de vídeo e protocolos de streaming. É capaz de transmitir mídia por redes de computadores e transcodificar arquivos multimídia. A distribuição padrão do VLC inclui\nmuitas bibliotecas de decodificação e codificação gratuitas, evitando a necessidade de\nencontrar/calibrar plugins proprietários.\n\n`•` **Audacity** : é um software livre de edição digital de áudio disponível principalmente nas\nplataformas: Windows, Linux e Mac e ainda em outros Sistemas Operacionais. O código\nfonte do Audacity está sob a licença _GNU General Public License_ . O Audacity é muito\npopular entre os podcasters por seus recursos de edição, sua grande disponibilidade em\nmúltiplas plataformas, suporte e licença abertas, que permite ao programa ser gratuito.\n\n`•` **ImageMagick** : o ImageMagick é uma ferramenta de linha de comando usada para\nconverter e editar a maioria dos tipos de arquivos de imagem. Também pode ser usado\npara criar documentos PDF a partir de arquivos de imagem e vice e versa.\n\n`•` **K3B** : é um programa de computador que funciona como uma interface gráfica para\na gravação de CD-ROMs e DVDs e funciona normalmente em sistemas operacionais\nda família Unix, tais como o Linux e o FreeBSD. Utiliza-se, para gravar mídias, dos\nprogramas cdrecord, cdrdao e growisofs. O K3B faz parte do projeto KDE. Permite criar,\nalém de CD-ROMs e DVDs de dados, CDs de áudio, CDs de vídeo e cópias exatas de\nCDs e DVDs.\n\n`•` **Blender** : é um programa de computador de código aberto, desenvolvido pela Blender\nFoundation, para modelagem, animação, texturização, composição, renderização, e\nedição de vídeo. Está disponível sob a GNU GPL, versão 2 ou posterior. O programa\né multiplataforma, estando portanto disponível para diversos sistemas operacionais. O\nBlender implementa ferramentas similares às de outros programas proprietários.\n\n\nO programa mais popular para a reprodução de vídeo é o VLC, mas alguns usuários preferem\noutras alternativas, como o smplayer. A reprodução de música local também traz muitas\nopções, como o Audacious, o Banshee e o Amarok, que também podem gerenciar uma coleção\nlocal de arquivos de áudio.\n\n### **Principais aplicações em servidores Open-Source**\n\n\n`•` **Apache HTTP Server** : o servidor HTTP Apache (do inglês Apache HTTP Server)\nou Servidor Apache ou HTTP Daemon Apache ou somente Apache, é um servidor web\nlivre criado em 1995 por Rob McCool. É a principal tecnologia da _Apache Software_\n\n\n38 6. Conhecendo o Linux\n\n\n_Foundation_, responsável por mais de uma dezena de projetos envolvendo tecnologias\nde transmissão via web, processamento de dados e execução de aplicativos distribuídos.\nÉ um servidor do tipo HTTPD, compatível com o protocolo HTTP versão 1.1. Suas\nfuncionalidades são mantidas através de uma estrutura de módulos, permitindo inclusive\nque o usuário escreva seus próprios módulos – utilizando a API do software.\n\n`•` **NGINX** : Nginx (lê-se “engine x”) é um servidor leve de HTTP, proxy reverso, proxy de\ne-mail IMAP/POP3, feito por Igor Sysoev em 2005, sob a licença BSD-like 2-clause.\n\n`•` **Lighttpd** : o servidor Lighttpd (pronuncia-se “lighty”), é um servidor web otimizado para\nambientes de velocidade crítica. Foi originalmente escrito por Jan Kneschke como uma\nprova de conceito do problema c10k – como lidar com 10.000 conexões em paralelo em\num servidor, ganhando popularidade mundial. Traz um gerenciamento eficaz da cpu-load\ne um conjunto de recursos avançados como FastCGI, SCGI, Auth, Output-Compression,\nURL-Rewriting etc.\n\n`•` **Apache Tomcat** : o Tomcat é um servidor web Java, mais especificamente, um container de servlets. O Tomcat implementa, dentre outras de menor relevância, as tecnologias Java Servlet e JavaServer Pages (JSP).\n\n`•` **Node.js** : interpretador de JavaScript assíncrono com código aberto orientado a eventos,\ncriado por Ryan Dahl em 2009, focado em migrar a programação do Javascript do\ncliente (frontend) para os servidores, criando aplicações de alta escalonabilidade (como\num servidor web), manipulando milhares de conexões/eventos simultâneas em tempo\nreal em uma única máquina física.\n\n`•` **Mariadb** : MariaDB Server é um dos bancos de dados relacionais de código aberto mais\npopulares. Destinado a permanecer como um software de código-fonte aberto e gratuito\nsob a _GNU General Public License_, foi criado pelos desenvolvedores originais do MySQL\nque o bifurcaram devido a preocupações sobre sua aquisição pela Oracle Corporation em\n2009. É parte da maioria das ofertas de nuvem e o padrão na maioria das distribuições\nLinux.\n\n`•` **PostgreSql** : também conhecido como Postgres, este é um poderoso sistema de banco\nde dados relacional de objetos de código aberto que usa e estende a linguagem SQL\ncombinada com muitos recursos que armazenam e escalonam com segurança as cargas\nde trabalho de dados mais complicadas. Tem uma forte reputação por sua arquitetura\ncomprovada, confiabilidade, integridade de dados, conjunto de recursos robustos, extensibilidade e dedicação da comunidade de código aberto por trás do software para\nfornecer soluções inovadoras e de alto desempenho de maneira consistente.\n\n`•` **Postfix** : o Postfix é um agente de transferência de e-mails (MTA) livre e de código\naberto que encaminha e entrega e-mails e tem como objetivo ser uma alternativa segura\nao Sendmail, muito utilizado em servidores UNIX. O Postfix foi originalmente escrito\nem 1997 por Wietse Venema no Centro de Pesquisa IBM Thomas J. Watson e teve a\nsua primeira versão lançada em 1998.\n\n`•` **Bind** : o BIND – _Berkeley Internet Name Domain_  - ou, como chamado previamente,\n_Berkeley Internet Name Daemon_ é o servidor para o protocolo DNS mais utilizado na\n\n\n39 6. Conhecendo o Linux\n\n\nInternet, especialmente em sistemas do tipo Unix, onde ele pode ser considerado um\npadrão, de fato.\n\n`•` **Squid** : o Squid é um servidor proxy que suporta HTTP, HTTPS, FTP e outros. Ele\nreduz a utilização da conexão e melhora os tempos de resposta fazendo cache de requisições frequentes de páginas web numa rede de computadores. Ele pode também ser\nusado como um proxy reverso.\n\n`•` **Hadoop** : plataforma Java de software de computação distribuída voltada para clusters\ne processamento de grandes volumes de dados, com atenção e tolerância a falhas. Foi\ninspirada no MapReduce e no GoogleFS (GFS). Trata-se de um projeto da Apache de\nalto nível, construído por uma comunidade de contribuidores e utilizando a linguagem\nde programação Java.\n\n`•` **Kubernetes** : Kubernetes (comumente estilizado como K8s) é um sistema de orquestração de contêineres open-source que automatiza a implantação, o dimensionamento\ne a gestão de aplicações em contêineres. Ele foi originalmente projetado pelo Google\ne agora é mantido pela Cloud Native Computing Foundation. Ele funciona com uma\nvariedade de ferramentas de conteinerização, incluindo Docker.\n\n### **Principais linguagens de programação Open-Source**\n\n\n`•` **Python** : linguagem de programação de alto nível, interpretada, de script, imperativa,\norientada a objetos, funcional, de tipagem dinâmica e forte. Foi lançada por Guido\nvan Rossum em 1991. Atualmente possui um modelo de desenvolvimento comunitário,\naberto e gerenciado pela organização sem fins lucrativos _Python Software Foundation_ .\n\n`•` **PHP** : um acrônimo recursivo para _Pre Hypertext Preprocessor_, originalmente _Personal_\n_Home Pages_ ) é uma linguagem interpretada livre, usada originalmente apenas para o\ndesenvolvimento de aplicações presentes e atuantes no lado do servidor, capazes de gerar\nconteúdo dinâmico na web.\n\n`•` **Java** : o Java é uma linguagem de programação orientada a objetos desenvolvida na\ndécada de 90 por uma equipe de programadores chefiada por James Gosling, na empresa\nSun Microsystems. Em 2008 o Java foi adquirido pela empresa Oracle Corporation.\nDiferentemente das linguagens de programação modernas, que são compiladas para\ncódigo nativo, a linguagem Java é compilada para um bytecode que é interpretado por\numa máquina virtual ( _Java Virtual Machine_, mais conhecida pela sua abreviação JVM).\n\n### **Apresentação dos principais gerenciadores de janelas usados no Linux**\n\n\nCom os gerenciadores de janela ( _window managers_ ), tanto a aparência quanto a localização\ndas janelas do X são administradas. Um dos diferenciais do GNU/Linux é permitir que o\npróprio usuário gerencie as janelas, em vez de conceder esse controle ao sistema, como é feito\npelos sistemas Apple e Microsoft, que oferecem apenas uma aparência básica.\n\n\n40 6. Conhecendo o Linux\n\n\nNo GNU/Linux, um computador pode ter vários gerenciadores de janela, cabendo ao usuário\nusar o que mais lhe convier. Entre os gerenciadores, temos: AfterSteps, Enlightenment,\nKwin (ambiente KDE), Blakbox, Evilwn, IceWM, FluxBox, SawFish, FVWM, Ion, Metacity\n(ambiente GNOME), WMN, OpenClasses (Sun), xfce e twm.\n\n\nOs gerenciadores de janela são diferentes entre si no que diz respeito a diversos fatores, tais\ncomo:\n\n```\n  •\n```\n\nRecursos necessários do computador;\n\n```\n  •\n```\nCustomização de funcionalidades e de aparência;\n\n```\n  •\n```\nConfiguração de menus;\n\n```\n  •\n```\nInterface gráfica;\n\n```\n  •\n```\nCapacidade de uso de vários computadores.\n\n\nMuitas distribuições GNU/Linux atuais disponibilizam ferramentas de acessibilidade voltadas\npara usuários com necessidades especiais, como problemas motores e visuais."
    },
    {
        "chapter_id": "7",
        "title": "Capítulo 7",
        "content": "# **7**\n\n## Tópicos para revisão do capítulo\n\nAtente para os tópicos a seguir. Eles devem ser estudados com muita atenção, pois representam\nos pontos mais importantes deste capítulo.\n\n```\n  •\n```\n\nUm sistema operacional é formado por um conjunto de funções que, trabalhando em\nperfeita harmonia, manipulam o hardware e, através de uma interface de comunicação,\noferecem todos os recursos úteis para o seu gerenciamento;\n\n```\n  •\n```\nA _Free Software Foundation_ é uma organização sem fins lucrativos cujo foco principal\né manter a GPL;\n\n```\n •\n```\nO Linux segue os princípios do software livre, ou seja, o usuário terá a liberdade de\nestudá-lo, executá-lo, alterá-lo, melhorá-lo, copiá-lo e até mesmo distribuí-lo;\n\n```\n •\n```\nTecnicamente, o Linux não é um sistema operacional, mas sim um kernel, ou melhor, o\ncentro de execução do seu sistema operacional. Cada sistema operacional, independentemente da plataforma, possui o seu próprio kernel, com suas características peculiares;\n\n```\n •\n```\nExiste uma quantidade imensa de distribuições disponíveis para instalação, com praticamente todos os níveis de dificuldade e focos específicos, como Debian, Slackware, Red\nHat, SUSE, entre outras;\n\n```\n •\n```\nA certificação LPI é uma das certificações mais procuradas por profissionais da área\nno mundo, por ser uma certificação internacional que é reconhecida por empresas, empregadores e profissionais do mundo de TI, além de ter grande destaque entre outras\ncertificações Linux.\n\n\nNo presente capítulo, aprenderemos a executar comandos para realizar tarefas básicas no\nsistema **GNU/Linux**, como, por exemplo, a inicialização de uma sessão. No entanto, antes\n\n\n41\n\n\n42 7. Tópicos para revisão do capítulo\n\n\nde executá-los, é importante compreender as características que esse sistema herda do padrão\nUnix, a estrutura do sistema operacional **GNU/Linux** e os conceitos de shell e bash. Este\núltimo é o interpretador de comandos comumente utilizado por sistemas Unix-like, como já\nvimos no capítulo anterior."
    },
    {
        "chapter_id": "8",
        "title": "Capítulo 8",
        "content": "# **8**\n\n## Estrutura do sistema operacional\n\nA estrutura de um sistema **GNU/Linux** é composta por porções denominadas camadas ( _lay-_\n_ers_ ). A figura a seguir demonstra a estrutura em camadas do sistema operacional **GNU/Linux** :\n\n\n43\n\n\n44 8. Estrutura do sistema operacional\n\n\nPara compreender de fato o que é esse sistema, é fundamental saber do que se trata cada\numa de suas camadas. Vejamos:\n\n\n45 8. Estrutura do sistema operacional\n\n\n`•` **Ambiente de trabalho (desktop environment)** : hospeda todos os programas cujo\nfuncionamento depende de um ambiente gráfico;\n\n`•` **DM (display manager)** : aqui são gerenciados os logins na interface gráfica e selecionado o tipo de ambiente gráfico que será executado;\n\n`•` **ttyn** : terminais virtuais que interpretam os comandos introduzidos por um usuário e os\nconvertem para uma linguagem inteligível pelo computador. Nessa camada os comandos\nsão executados e as configurações são definidas;\n\n`•` **Sistema Operacional** : camada que auxilia e hospeda todos os aplicativos das camadas\nsuperiores, mencionadas anteriormente;\n\n`•` **Kernel Linux** : mediadora entre as camadas superiores e o hardware, essa camada é o\nnúcleo do sistema operacional;\n\n`•` **Hardware** : camada que compreende os dispositivos do sistema disponíveis para uso,\ncomo CD-ROM, teclado, monitor, entre outros.# Introdução\n\n### **Sessões**\n\n\nUma sessão é composta pelos dados gerados após o login de um usuário válido cadastrado no\nsistema e efetuado com sucesso no ambiente. Esse login dará acesso direto ao interpretador\nde comandos padrão determinado no sistema, que geralmente será o bash. As sessões são\niniciadas através dos terminais, que são caracterizados como terminal virtual somente em\nmodo texto ou pseudoterminal inicializado a partir de um ambiente gráfico. A única diferença\nentre eles é a forma de acesso. A seguir, falaremos sobre esses terminais.\n\n\n**Terminal virtual em modo texto**\n\n\nO conjunto teclado/monitor conectado à máquina compreende o que chamamos de terminal,\nou console. Por meio de terminais virtuais, o GNU/Linux permite que diversos usuários se mantenham simultaneamente conectados, pondo em prática o aspecto multiusuário/multitarefa,\ncaracterístico do padrão Unix.\n\n\nCom programas como rlogin, ssh, rsh, rdesktop e telnet, podemos acessar terminais virtuais\nremota ou localmente.\n\n\nUm terminal virtual em modo texto é prático e rápido, pois não é necessário esperar o ambiente\ngráfico carregar para iniciar uma sessão a partir do mesmo. Geralmente, em servidores, o\nrecurso de ambiente gráfico não está habilitado. Em casos como esse, assim que o processo\nde inicialização do sistema for concluído, o primeiro terminal estará disponível aguardando um\nlogin para o início de uma sessão.\n\n\nÉ possível ter acesso a outros terminais que trabalham de forma completamente independente.\nO GNU/Linux apresenta precisamente **63 terminais** em modo texto, mas, por questões de\nconsumo de memória RAM, somente 6 são disponibilizados por padrão.\n\n\n46 8. Estrutura do sistema operacional\n\n\nPara acessá-los é muito simples. Basta manter pressionada a tecla **ALT** e, em seguida,\npressionar a tecla de função correspondente ao terminal que desejamos acessar (teclas F1 até\nF6). Se estivermos no primeiro terminal, temos o seguinte:\n\n\nTerminal Nome Tecla de atalho para acesso\n\n\nPrimeiro tty1 (CTRL +) ALT + F1\nSegundo tty2 (CTRL +) ALT + F2\nTerceiro tty3 (CTRL +) ALT + F3\nQuarto tty4 (CTRL +) ALT + F4\nQuinto tty5 (CTRL +) ALT + F5\nSexto tty6 (CTRL +) ALT + F6\n\n\nNota sobe CTRL + ALT +F(n): caso o terminal padrão não seja um terminal em modo texto,\né preciso utilizar também a tecla ALT.\n\n\nTeremos então, na primeira linha, o nome e a versão do sistema operacional, o nome do\ncomputador e o nome do terminal em que estamos localizados. Na figura que mostra o\nterminal a seguir, temos **Debian GNU/Linux 10 debian tty1** :\n\n\nOnde:\n\n```\n  •\n```\n\nDebian GNU/Linux 10 é o nome e a versão do sistema operacional;\n\n```\n  •\n```\ndebian é o nome da máquina;\n\n```\n  •\n```\ntty1 indica o primeiro terminal.\n\n\n**Pseudoterminal**\n\n\nUm pseudoterminal é, basicamente, um terminal virtual inicializado a partir do ambiente\ngráfico. Tem a mesma função do terminal em modo texto, porém depende da execução do\nambiente gráfico para que seja carregado. Os gerenciadores de janelas, como o KDE ou\n\n\n47 8. Estrutura do sistema operacional\n\n\n- GNOME, têm aplicações específicas que emulam um terminal no ambiente gráfico, como\nkonsole no KDE, ou o próprio terminal no GNOME.\n\n### **Execução dos primeiros comandos**\n\n\nVejamos, a seguir, como executar os primeiros comandos a partir do shell do GNU/Linux, a\nfim de iniciar e encerrar uma sessão, desligar e reiniciar o sistema e obter ajuda a respeito da\nutilização de comandos.\n\n\n**Início de uma sessão (login)**\n\n\nDepois de conhecer melhor os terminais, que são a porta de entrada para o sistema, é hora de\niniciar uma sessão em modo texto (fazer o login), pois esta exigirá, em um sistema configurado\nde modo seguro, que seja feita uma autenticação com um usuário previamente cadastrado. Em\nqualquer um dos terminais virtuais em modo texto, basta inserir o login e a senha, lembrando-se\nda característica case-sensitive presente no sistema. Então, a sessão é iniciada, como mostrado\nna figura a seguir:\n\n\nAssim que a autenticação for executada com sucesso, o prompt principal do interpretador de\ncomandos utilizado é apresentado, e o sistema já pode ser operado.\n\n\nSobre o prompt principal citado anteriormente, teremos muitas informações caso o interpretador de comandos seja o bash. Caracteres como,, :, - e @ são utilizados apenas para separar\ninformações e formar o prompt principal. O caractere $ identifica que o usuário atual não tem\npermissões ou poderes de superusuário para executar determinadas operações .\n\n\nusername@mycomputer:~$\n\n\n48 8. Estrutura do sistema operacional\n\n\nPara executar comandos com poderes administrativos, temos várias maneiras e uma delas é\nalterar o nível de usuário de comum para superusuário. Para isso, podemos utilizar o comando\n\nsudo -i. Ao digitar sudo -i na linha de comando e teclar ENTER, é solicitada a senha de seu\nusuário.\n\n\nusername@mycomputer:/$ sudo -i\nSenha:\nroot:/#\n\n\nOutra maneira, seria alterar o login para o usuário root:\n\n\nusername@mycomputer:/$ su Senha:\nroot:/#\n\n\nO comando su - ( _substitute user_ ), tem a finalidade de alterar a sessão para outro usuário,\nneste caso como não informamos nenhum após o -, por padrão será o usuário root.\n\n\nEm vez de um $, teremos o caractere #, indicando que o usuário agora é um superusuário.\n\n\nExistem dois comandos, **whoami** e **who am i** que lhe permite saber quem você é em determinado momento. A sequência de comandos abaixo esclarece o uso e finalidade destes dois\ncomandos claramente:\n\n\nwhoami\nwho am i\n\n\nO comando whoami indica quem você é no momento root. Se você utilizou o comando su para\ntornar-se outro usuário o comando whoami informa quem você realmente é **aluno**, pois foi com\nele que você se logou na máquina antes de trocar de usuário.\n\n\nEle também pode ser utilizado para trocar de usuário, ele não pedirá a senha se você for\nusuário root:\n\n\nsu - aluno\n\n\nTodas essas informações sobre o prompt principal poderão ser alteradas através de variáveis\n\n\n49 8. Estrutura do sistema operacional\n\n\nde ambiente.\n\n\n**Encerrando uma sessão (logout)**\n\n\nApós uma sessão em modo texto ser inicializada, é possível fechá-la (fazer o logout) com os\ncomandos logout ou exit. A seguir veja o shell com o comando exit digitado:\n\n\nusername@mycomputer:~$ exit\n\n\nA sequência de teclas CTRL + D também pode ser utilizada para finalizar uma sessão.\n\n\n**Desligamento do sistema**\n\n\nSob o nível de usuário root, o desligamento do computador pode ser realizado por um dos\nseguintes comandos:\n\n\nshutdown –h now\n\n\nou:\n\n\nhalt -p\n\n\nou:\n\n\npoweroff\n\n\nou:\n\n\ninit 0\n\n\nAinda que o computador possa ser desligado diretamente pelo botão liga/desliga, sem a\nutilização de nenhum dos comandos citados, esse procedimento deve ser evitado sempre que\npossível, pois os programas que não forem fechados e os dados não gravados podem gerar\nfalhas no sistema de arquivos e perda de dados.\n\n\n50 8. Estrutura do sistema operacional\n\n\nDessa forma, para garantir a segurança do sistema, o usuário deve escolher um dos três\ncomandos de desligamento disponíveis, que automaticamente executam esses processos de\nencerramento da maneira adequada. Salvar manualmente os arquivos antes do desligamento\ne considerar o uso de um nobreak são outras medidas de segurança possíveis.\n\n\nO comando shutdown poderá ser utilizado para desligar ou reiniciar o sistema.\n\n\nPara desligar o sistema, utiliza-se a sintaxe shutdown -h <tempo>, onde <tempo> define o momento\n(em minutos) em que ocorrerá o desligamento e h significa halt ou seja, desligar o sistema.\n\n\nPara desligar o sistema imediatamente, digitamos o comando now (agora) conforme a seguinte\nlinha:\n\n\nshutdown -h now\n\n\nAo utilizar o parâmetro now, os processos atualmente executados são encerrados antes do\ndesligamento da máquina. Outro meio de desligar o sistema imediatamente é utilizar o valor\n\n0 (zero).\n\n\nshutdown -h 0\n\n\nPara desligar o sistema daqui a 10 minutos, por exemplo, digitamos o seguinte:\n\n\nshutdown -h 10\n\n\nPara desligar o sistema exatamente às 17:00, por exemplo, digitamos o seguinte:\n\n\nshutdown -h 17:00\n\n\nOs comandos halt ou poweroff também podem ser utilizados para desligar o sistema de forma\nsimples e direta, mas sem a opção de poder especificar o tempo. Em computadores antigos, o\nusuário precisará apertar o botão liga/desliga, quando a mensagem power down aparecer, após\n\n- envio do comando halt.\n\n\n51 8. Estrutura do sistema operacional\n\n\n**Reiniciar o sistema**\n\n\nÉ recomendável não reiniciar o sistema através dos botões liga/desliga e RESET, pois, como\njá mencionado, o desligamento abrupto do computador pode causar não só a perda de dados\nnão salvos adequadamente, mas também falhas nos sistemas de arquivos. Existem comandos\nespecíficos para reiniciar o sistema de forma segura, e os botões citados devem ser evitados e\nusados somente em último caso.\n\n\nPara reiniciar o sistema, podemos utilizar, como no desligamento, o comando shutdown. No\nentanto, utilizamos o parâmetro **–r** (proveniente de reboot) em vez de -h, como mostra esta\nsintaxe:\n\n\nshutdown -r <tempo>\n\n\nO momento em que deve ocorrer a reinicialização deve ser especificado em <tempo>. No exemplo\na seguir, o comando shutdown reiniciará o sistema daqui a 10 minutos:\n\n\nshutdown -r 10\n\n\nPara reiniciar imediatamente o sistema, digitamos a seguinte linha:\n\n\nshutdown -r now\n\n\nO comando reboot ou a sequência de teclas CTRL + ALT+ DEL também pode ser utilizado de\nforma simples para reiniciar o sistema, mas sem a opção de poder especificar o tempo. Antes\nde reiniciar o sistema, todos os arquivos abertos devem ser salvos, para evitar acidentes."
    },
    {
        "chapter_id": "9",
        "title": "Capítulo 9",
        "content": "# **9**\n\n## O que é um Shell\n\nSabemos que o principal meio de interação do usuário com um sistema GNU/Linux é o terminal\nde comandos, também conhecida como **shell** . Portanto e possível afirmar que o **shell** é uma\ncamada de acesso ao sistema básico, o sistema operacional do computador, que pode ser\nacessada tanto pelo modo gráfico, quanto pelo modo texto. O **shell** pode ser personalizado\npara atender as necessidade do usuário.\n\n\nPode-se definir um idioma padrão, personalizar e automatizar processos. Nos tópicos a seguir,\nveremos como fazer essa personalização. A figura abaixo ilustra como podemos posicionar a\n**shell** dentro do sistema.\n\n\n52\n\n\n53 9. O que é um Shell\n\n### **Tipos de shell**\n\n\nHá diversos tipos de shell disponíveis para distribuições **GNU/Linux** . O bash é o tipo utilizado\nna maioria das distribuições. A seguir, temos a descrição dos principais tipos de shell:\n\n\n`•` **sh (Bourne shell)** : desenvolvido por Stephen Bourne, por isso seu nome. É o shell\noriginal, bem simples, com poucas ferramentas, mas ainda utilizado em sistemas UNIX\ne ambientes relacionados ao UNIX.\n\n`•` **bash (Bourne Again shell)** : trata-se do shell padrão do Linux, conveniente tanto\npara usuários iniciantes, por ser intuitivo e flexível, quanto para usuários avançados e\nprofissionais, por possuir ferramentas variadas e eficientes. Compatível com todos os\ncomandos do sh.\n\n`•` **csh (C shell)** : o preferido de alguns programadores. A sintaxe desse shell é semelhante\nà linguagem de programação C.\n\n`•` **tcsh (Turbo C shell)** : versão melhorada do csh, que interpreta linguagens de comando\ne pode ser usada tanto como um shell de login interativo quanto como um processador\nde comandos de shell scripts. É completamente compatível com o csh.\n\n`•` **ksh (Korn shell)** : este shell é o Bourne Shell evoluído, portando todos os comandos\nque funcionavam no Bourne Shell funcionarão aqui, com a vantagem de ter mais opções.\n\n\n54 9. O que é um Shell\n\n\n`•` **zsh (Z shell)** : além de um shell desenvolvido para uso interativo, que engloba várias\nfunções úteis do **bash**, **ksh** e **tcsh**, o **zsh** é também uma linguagem de script eficiente.\n\n### **Alteração do shell atual**\n\n\nPara alterar o shell atual, utilizamos o comando chsh com a opção -s ou --shell, seguido do\nnome do shell que se deseja utilizar.\n\n\nA linha a seguir altera o shell para o sh:\n\n\nchsh -s /bin/sh"
    },
    {
        "chapter_id": "10",
        "title": "Capítulo 10",
        "content": "# **10**\n\n## Variáveis\n\nPodemos definir variáveis como nomes que contêm algum valor e, ainda, como espaços de\nmemória que armazenam valores. Sua função é o fornecimento de dados variáveis úteis e\nnecessários a usuários e programas. Tais variáveis apresentam a seguinte forma:\n\n\nNOME=VALOR\n\n\nou seja:\n\n\n4LINUX=joatham\n\n\nEsse tipo de variável que acabamos de definir é conhecida como **escala** e pode receber valores\nnuméricos ou caracteres.\n\n\nPara acessar o endereço de memória atribuído à variável 4LINUX, em **shell**, devemos utilizar o\noperador $ (cifrão) antes do nome da variável, ou seja, se desejarmos mostrar na tela o valor\nda variável 4LINUX devemos imprimir o conteúdo armazenado no endereço de memória $4LINUX:\n\n\necho $4LINUX\n\n\n55\n\n\n56 10. Variáveis\n\n\nInteressante observar o comando echo, que por sua vez é usado para imprimir algo na tela ou\ndirecionar para um arquivo. Isso é bastante útil para automação.\n\n\nNesse caso na linha de comando o echo é útil para inspecionar variáveis de ambiente, que são\nparâmetros guardados em memória e que definem o ambiente em uso.\n\n\nDeixa eu te mostrar como se faz.\n\n\nPara imprimir algo na tela:\n\n\necho algo\n\n\nVamos definir a variável **comando** com o valor igual a ls:\n\n\ncomando=ls\n\n\nPara verificarmos o valor da variável podemos digitar:\n\n\necho $comando\n\n\nOu\n\n\necho \"$comando\"\n\n\nPara escrevermos na tela: **$comando**, digite:\n\n\necho ’’$comando\n\n\nE por fim para executarmos o valor da variável **comando**, digite:\n\n\necho ‘‘$comando\n\n\nOu\n\n\n57 10. Variáveis\n\n\necho $($comando)’\n\n### **Variáveis Locais e de Ambiente (globais)**\n\n\nQuando falamos em variáveis em **shell** temos que ter em mente a divisão entre variáveis locais\ne de ambiente (ou globais).\n\n\n`•` **Variáveis locais** : são as variáveis disponíveis somente para o shell atual. Isso significa\nque sua visibilidade é restrita ao ambiente para o qual foram definidas, ou seja, elas não\nficam disponíveis para o restante do sistema.\n\n`•` **Variáveis globais (de ambiente)** : são as variáveis disponíveis tanto para o shell atual\ncomo para os subprocessos que as utilizam, de forma que sua visibilidade é aberta a\noutros ambientes além daqueles em que elas são definidas.\n\n\nVejamos algumas variáveis de ambiente na tabela abaixo:\n\n\n**Variável** **Definição**\n\n\nHOME Responsável por identificar o diretório do usuário.\nHOSTTYPE Faz referência à plataforma que está sendo utilizada.\nSHELL Permite identificar o shell que está sendo utilizado.\nTERM Define o tipo de terminal que está sendo utilizado.\nUSER Predefine o nome da conta como variável global.\nPATH Determina quais diretórios devemos pesquisar e, ainda, qual sequência\ndeverá ser seguida para encontrar um determinado comando.\nPS1 Representa as informações exibidas no prompt.\nPS2 Representa o prompt estendido.\nMAIL Esta variável informa como o correio eletrônico está definido.\nLOGNAME É um sinônimo da variável USER.\nOSTYPE Com a utilização desta variável, é possível definir o tipo de sistema\noperacional que está sendo utilizado.\n\n\n**Como definir variáveis**\n\n\nA única diferença técnica entre variáveis locais e de ambiente é a forma de sua definição.\n\n\nPara definir uma variável local, basta atribuir um valor a um nome de variável.\n\n\nPara definir uma variável de ambiente o procedimento adiciona o comando export antes da\n\n\n58 10. Variáveis\n\n\ndefinição.\n\n\nAbaixo mostramos exemplos de definição de variável local e de ambiente:\n\n\nLOCAL=\"sem export na frente\"\nexport GLOBAL=\"com export na frente\"\n\n\nVejamos o seguinte exemplo:\n\n\nLOCAL=\"Variável Local\"\necho $LOCAL\nVariável Local\nexport GLOBAL=\"Variável Global\"\necho $GLOBAL\nVariável Global\n\n\nNo exemplo que acabamos de ver, foi criada uma variável local chamada LOCAL, a qual estará\ndisponível apenas a esta seção. Para visualizar o retorno da variável, foi utilizado o comando\n\necho. Em seguida, por meio do comando export, foi criada uma variável global, que estará\ndisponível para todas as seções do sistema. Por fim, para verificar o retorno da variável global\ncriada, o comando echo também foi utilizado.\n\n\nUma vez definidas as **variáveis**, podemos visualizá-las utilizando os comandos set e env ou\n\nprintenv para variáveis locais e de ambiente, respectivamente. Com isso, se tivéssemos definido\nas variáveis LOCAL e GLOBAL e executássemos o comando set, veríamos as definições de ambas.\nMas, se executássemos o comando env, veríamos apenas a definição da variável GLOBAL\n\n\nmagica=\"abracadabra\"\necho $magica\nset\nclear\nenv\n\n\nAbra um terminal filho:\n\n\nbash\n\n\nNão há nada na variável, pois ela não foi exportada:\n\n\n59 10. Variáveis\n\n\necho $magica\nexit\n\n\nExporte a variável:\n\n\nexport magica\nset\nclear\nenv\n\n\nAbra um terminal filho:\n\n\nbash\n\n\nAgora existe um valor para a variável:\n\n\necho $magica\n\n\nUtilizamos o comando unset para excluir variáveis. Sua sintaxe é a seguinte:\n\n\nunset <variavel>\n\n\n**Exclusão de variáveis**\n\n\nÉ importante lembrar que esse comando, quando usado para uma variável global, só tem efeito\nna sessão atual, de forma que a variável continuará acessível em outras sessões.\n\n\nunset magica\necho $magica\n\n\nPara ficar permanente para todos e funcionar em qualquer terminal deve-se colocarem um dos\narquivos:\n\n\n60 10. Variáveis\n\n\n/etc/profile\n/etc/environment\n\n\nPara ficar permanente para o usuário e funcionar em qualquer terminal deve-se colocar em um\ndos arquivos:\n\n\n~/.bashrc\n~/.bash_profile\n~/.bash_login4\n~/.profile\n\n\n**Alterar o prompt de comando**\n\n\nVariáveis de ambiente (as globais) são muito s pois definem o comportamento da“shell” e de\nmuitos outros programas”\n\n\nPara que possamos alterar o prompt de comandos, devemos alterar os valores que estão\narmazenados dentro da variável PS1.\n\n\nNa tabela a seguir, serão descritos alguns valores que podem ser utilizados em conjunto com\na variável PS1:\n\n\n**Valor** **Descrição**\n\n\n**h** Faz referência ao nome do host.\n**w** Caminho completo do diretório corrente.\n**W** Refere-se ao diretório atual.\n**u** Exibe o nome do usuário.\n**t** Exibe a hora do sistema.\n**d** Refere-se à data do sistema.\n\n\n**∗∗| _Especificaovalor_ ‘para usuários comuns, e o valor#para o usuárioroot‘.\n\n\nNo exemplo adiante, alteramos a variável PS1 para que o prompt exiba o nome do usuário, o\nnome do host e a hora atual:\n\n\nexport PS1='[u@h-t]'\n\n[root@mycomputer-16:55:59]\n\n\n61 10. Variáveis\n\n\nVolte a configuração anterior:\n\n\nsource /etc/profile"
    },
    {
        "chapter_id": "11",
        "title": "Capítulo 11",
        "content": "# **11**\n\n## Arquivos de configuração do shell\n\nAlguns arquivos são automaticamente lidos pelo shell no momento do login e do logout de\num usuário ou ainda no momento da chamada do shell a partir de uma sessão que já tenha\nsido iniciada. Dependendo de como for iniciado o bash, arquivos diferentes serão executados\nde forma automática e, a partir desse conhecimento, o usuário pode programar a criação de\nvariáveis, aliases, funções e outras personalizações do bash.\n\n\nCaso o bash seja invocado durante um login, ele lerá os arquivos /etc/profile, ~/.bash_profile\n, ~/.bash_login e ~/.profile, nessa ordem, caso eles existam. O primeiro aplica-se a todos\nos usuários do sistema, ao passo que os três últimos, ocultos por iniciarem com um ponto\n(.), estão no diretório /home do usuário em questão. Ao terminar a sessão, o bash executará\nautomaticamente o arquivo ~/.bash_logout, se ele existir.\n\n\nQuando não se tratar de um shell invocado numa sessão de login, como é o caso de terminais\nem sessões X, os arquivos executados automaticamente, caso existam, serão o /etc/bash.bashrc\ne ~/.bashrc.\n\n\nVejamos separadamente alguns arquivos de configuração importantes.\n\n\nArquivo /etc/profile:\n\n\nO arquivo /etc/profile é executado automaticamente no momento do login e lido antes dos\narquivos de configurações pessoais do usuário. É responsável, ainda, por definir as variáveis\nde ambiente para os usuários em geral e armazenar os comandos a serem executados, quando\n\n\n62\n\n\n63 11. Arquivos de configuração do shell\n\n\n- usuário efetuar o login no sistema. Sempre que o arquivo for carregado por meio de um\nshell que solicita login, ele procurará os arquivos na sequência descrita no início deste tópico\ne realizará a execução dos comandos nele contidos, caso eles existam.\n\n\nArquivo /etc/environment:\n\n\nO arquivo /etc/environment é utilizado por sistemas Debian para definir variáveis de ambiente.\nUma vez definidas, todas as variáveis são exportadas, automaticamente, na inicialização do\nsistema. Esse arquivo substitui o arquivo /etc/profile em algumas distribuições.\n\n\nArquivo /.bashrc:\n\n\nExecutado por shells invocados em sessões já iniciadas, e não de login, esse arquivo possui\ncaracterísticas semelhantes às do arquivo ~/.bash.profile.\n\n### **Utilização de aliases (apelidos)**\n\n\nAlguns comandos têm uma sintaxe indiscutivelmente grande e digitá-la inteira toda vez que o\ncomando for necessário tende a se tornar uma tarefa inconveniente, especialmente quando o\ncomando é usado diversas vezes com os mesmos argumentos e opções.\n\n\nUma forma bastante útil de agilizar a entrada de um comando que seja usado normalmente\ncom os mesmos parâmetros é atribuir um alias, que provém da palavra _apelido_ em inglês.\nEm linha de comando ou em um arquivo próprio para isso, atribui-se um termo pequeno e de\ndigitação fácil para executar um determinado comando com parâmetros específicos toda vez\nque este alias for usado.\n\n\nNo exemplo a seguir, executamos propositalmente l, que é um comando inexistente. Em\nseguida, com o comando alias, especificamos que ao digitar l o comando a ser executado\nserá igual a ls --color -l -a. Então, ao executarmos novamente o comando l, ele passa a\nresponder como o comando ls e com os parâmetros --color -l -a**.\n\n\nIsso será particularmente útil para administradores de sistema, por exemplo, que precisam\nexecutar comandos específicos diariamente, consultar processos em execução etc., de forma\nque seja possível automatizar o trabalho, ou pelo menos, torná-lo menos moroso.\n\n\n64 11. Arquivos de configuração do shell\n\n\nPara remover o alias de um comando, utiliza-se o comando unalias, como mostra este exemplo\nda figura a seguir, que exclui o alias l criado no exemplo anterior:\n\n\n65 11. Arquivos de configuração do shell\n\n### **Arquivos para exibição de mensagens**\n\n\nExistem três arquivos relacionados à exibição de imagens para usuários, que não afetam a\nparte operacional do sistema. O primeiro deles é o /etc/issue, que exibe uma mensagem para\num usuário antes do login no sistema. Caso queira que a mensagem apareça depois do login,\n\n- arquivo utilizado é o /etc/motd. Para visualizar mensagens exibidas em logins remotos, o\narquivo a ser verificado é o /etc/issue.net.\n\n\nArquivo .bash_history:\n\n\nO .bash_history é um arquivo responsável por armazenar o histórico de linhas de comando.\nPor padrão, até 500 comandos podem ser armazenados nesse arquivo, que pode ser verificado\npor comandos que exibem o seu conteúdo. Por meio das setas direcionais no teclado, para\ncima e para baixo, podemos verificar quais comandos já foram utilizados.\n\n\nO arquivo .bash_historytambém armazena sua configuração em algumas variáveis. Vejamos\n\n\n66 11. Arquivos de configuração do shell\n\n\nquais são elas na tabela abaixo:\n\n\n**Variável** **Descrição**\n\n\n**HIST-** Armazena o nome do arquivo utilizado para armazenar históricos.\n**FILE**\n\n**HIST-** Armazena o número máximo de comandos que o arquivo suportará.\n**SIZE**\n\n\n\n**HIST-**\n**FILE-**\n**SIZE**\n\n\n\nArmazena o número máximo de linhas que o arquivo do histórico de\ncomandos suportará.\n\n\n### **Histórico de comando**\n\nDo ponto de vista prático, esse recurso traz grande praticidade ao usuário, pois não é necessário\nredigitar diversas vezes um mesmo comando.\n\n\nPara manter o histórico dos comandos utilizados, basta digitar history na linha de comando e\nentão ENTER. Por meio das teclas direcionais para cima e para baixo do teclado, temos acesso\nao histórico. Veja um exemplo da execução do comando history:\n\n\nhistory\n\n\n93 su 94 lpsci\n95 sudo -s\n96 aptitude search chromium\n97 history\n\n\nNo exemplo a seguir, utilizamos o comando history para exibir os últimos 10 comandos digitados:\n\n\nhistory 10\n\n493 reset\n494 set | grep LOCAL\n495 set | grep GLOBAL\n496 echo $GLOBAL\n497 set | grep LOCAL\n498 unset LOCAL\n499 set | grep LOCAL\n500 sudo -s\n501 df -h\n502 history 10\n\n\n67 11. Arquivos de configuração do shell\n\n### **Comando fc**\n\n\n**FC** significa **Find Command** ou **Fix Command** pois ele executa as duas tarefas, encontrar\ne corrigir comandos. Para listar os comandos já digitados, guardados no history, digite:\n\n\nfc -l\n\n\nPor padrão mostra os últimos 16 comandos. Para visualizar uma lista de comandosdo 2 ao 6\nfaça:\n\n\nfc -l 2 6\n\n\nPara visualizar os ultimos 20 comandos:\n\n\nfc -l -20\n\n\nPara visualizar todos os comandos desde o ultimo comecando com h:\n\n\nfc -l h"
    },
    {
        "chapter_id": "12",
        "title": "Capítulo 12",
        "content": "# **12**\n\n## Caminhos de Diretorios\n\nComo vimos, há várias boas interfaces gráficas de usuário, ou GUIs, disponíveis para tornar os\nusuários mais produtivos.\n\n\nMas de vez em quando você pode ter que fazer alguma coisa a partir da linha de comando do\nLinux, e é importante saber onde você está na estrutura de arquivos do Linux.\n\n\nLinux são hierárquicos, ou seja, há um diretório de nível superior chamado **Raiz**, que é identificado como apenas uma barra /. A **Raiz** tem sub-diretórios organizados sob ele, como\n\n/home,/bin e /usr.\n\n\nOs chamados “caminhos” de diretório, são locais no sistema onde são armazenadas localizações\nfísicas de arquivos, pastas, scripts e demais recursos do sistema e consistem em caminhos\nabsolutos e caminhos relativos.\n\n\n**Caminho absoluto** é o caminho completo de um arquivo ou subdiretório desde a raiz. Por\nexemplo: /proc/cpuinfo.\n\n\nOnde, cpuinfo é um arquivo que está abaixo do diretório proc e o diretório proc está abaixo do\ndiretório / (raiz).\n\n\nÉ importante ressaltar que o **caminho absoluto** começará sempre com /. Desta forma,\nao acessar um arquivo ou um diretório por meio do caminho absoluto não importa em qual\ndiretório atual (corrente) você esteja.\n\n\n68\n\n\n69 12. Caminhos de Diretorios\n\n\nJá o **caminho relativo** é usado quando não é indicado o diretório raiz para acessar um\nsubdiretório ou um arquivo qualquer. Para que o caminho relativo funcione você precisa saber\nem qual diretório está localizado atualmente no sistema e ter uma boa noção de onde ficam\nlocalizados os principais diretórios e arquivos. Abaixo seguem alguns atalhos para acessar\ndeterminados diretórios.\n\n\nCaminhos de diretórios:\n\n\n1. . – diretório corrente\n2. .. – diretório pai\n3. / – diretório raiz\n4. \\-– diretório anterior\n\n\nO comando pwd ( _print name of current/working directory_ ) significa: imprima o nome do\ndiretório corrente no qual estou trabalhando agora, e é usado para saber em qual diretório\nvocê está no momento.\n\n\ncd /home\npwd\ncd /tmp\npwd\ncd ~\npwd\n/bin/ls\n\n\nAs linhas 1, 3 e 7 dos comandos acima são absolutas. Observe que todos estes caminhos\ncomeçam com barra (/). O que permite você executar o comando ls sem indicar o caminho\nabsoluto é a existência da variável de ambiente $PATH, que armazena os diretórios nos quais\n\n- sistema deve buscar os executáveis. O diretório /bin está presente na variável de ambiente\n\n$PATH de todo usuário comum.\n\n\nPara visualizar o conteúdo da variável de ambiente $PATH do usuário corrente execute o comando:\n\n\necho $PATH\n/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\n\n\nObserve que cada diretório presente na variável de ambiente $PATH é separado por dois pontos\n(:). Por enquanto, ainda não é nosso objetivo entrar em detalhes sobre as variáveis de ambiente\ndo sistema.\n\n\n70 12. Caminhos de Diretorios\n\n\n**Caminho relativo:**\n\n\npwd\n/tmp\ncd ..\npwd\n/\ncd pwd\n/tmp\n\n\nAs linhas 3 e 6 dos comandos acima usam caminho relativo. O resultado destes comandos\ndependem de qual diretório você está no momento, por isso o nome caminho relativo.\n\n\n**Caminho relativo:**\n\n\ncd /bin\n./ls\necho \"Certificação LPIC-1\"\necho $PATH\n/usr/share/sbin:/usr/local/bin:/usr/sbin:/usr/bin:\n/sbin:/bin\n\n\n**Caminho relativo:**\n\n\ncd /usr/share/doc\npwd\n/usr/share/doc\ncd ../../\npwd\n/usr\n\n\nA linha 4 dos comandos acima usa um caminho relativo e sobe dois níveis na árvore de\ndiretórios.\n\n### **Acessando os diretórios**\n\n\nVamos aprender agora alguns comandos essenciais para a nossa movimentação dentro do\nsistema.\n\n\nO comando cd é utilizado para mudar o diretório atual de onde o usuário está. Ir para o\ndiretório home do usuário logado:\n\n\n71 12. Caminhos de Diretorios\n\n\ncd\ncd ~\n\n\nIr para o início da árvore de diretórios, ou seja, o diretório /:\n\n\ncd /\n\n\nIr para um diretório específico:\n\n\ncd /etc\n\n\nSobe um nível na árvore de diretórios:\n\n\ncd ..\n\n\nRetorna ao diretório anterior:\n\n\ncd \n\nEntra em um diretório específico:\n\n\ncd /usr/share/doc\n\n\nSobe 2 níveis da árvore de diretórios:\n\n\ncd ../../\n\n\n**Comando ls**\n\n\nO comando ls é utilizado para listar o conteúdo dos diretórios. Se não for especificado nenhum\ndiretório, ele irá mostrar o conteúdo daquele onde estamos nomomento. Lista o conteúdo do\n\n\n72 12. Caminhos de Diretorios\n\n\ndiretório atual:\n\n\nls\n\n\nPara listar o conteúdo do diretório corrente com saída colorida faça:\n\n\nls --color\n\n\nPara listar todo o conteúdo (inclusive os arquivos ocultados) do diretório corrente:\n\n\nls -a\n\n\nO arquivos ocultados no Linux começam com um . (ponto).\n\n\nO asterisco é um coringa que representa nenhum ou mais caracteres.\n\n\nls /dev/sd*\n/dev/sda /dev/sda2 /dev/sda4 /dev/sdb /dev/sdb2\n/dev/sda1 /dev/sda3 /dev/sda5 /dev/sdb1\n\n\nls /etc/host*\n/etc/host.conf /etc/hostname /etc/hosts /etc/hosts.allow /etc/hosts.deny\n\n\nO ponto de interrogação representa um único caractere ao contrário do asterisco. Observe a\nsaída do comando abaixo. Temos dois pontos de interrogação que serão substituídos por dois\ncaracteres:\n\n\nls /dev/s??\n/dev/sda /dev/sdb /dev/sg0 /dev/sg1 /dev/sg2 /dev/sr0\n\n\n/dev/shm:\npulse-shm-1570592226 pulse-shm-2671603769 pulse-shm-525798260\npulse-shm-1851567380 pulse-shm-3911461625 pulse-shm-665496239\npulse-shm-252084306 pulse-shm-4228683900 pulse-shm-882637142\n\n\n/dev/snd:\nby-path controlC0 hwC0D2 pcmC0D0c pcmC0D0p pcmC0D2p seq timer\n\n\n73 12. Caminhos de Diretorios\n\n\nO comando abaixo mostrará todos arquivos que começam com sd e terminam com a, b ou c:\n\n\nls /dev/sd[abc]\n/dev/sda /dev/sdb\n\n\nO comando abaixo mostrará todos os arquivos que começam com sda, mas que não é seguido\npor 0 ou 1:\n\n\nls /dev/sda[!01]\n/dev/sda2 /dev/sda3 /dev/sda4 /dev/sda5\n\n### **Atalhos de teclado utilizados na linha de comando**\n\n\nAo digitar comandos no shell do sistema GNU/Linux, podemos fazer uso de atalhos de teclado\npara agilizar tarefas, tais como apagar e copiar caracteres, mover o cursor para o local desejado,\nabrir uma nova linha de comando, entre outras descritas a seguir:\n\n\n`•` **HOME** ou **CTRL + A** : leva o cursor para o início da linha de comandos.\n\n`•` **END** ou **CTRL + E** : leva o cursor para o fim da linha de comandos.\n\n`•` **BACKSPACE** : apaga o caractere à esquerda do cursor.\n\n`•` **CTRL + U** : apaga tudo o que estiver à esquerda do cursor, porém permite colar o\nconteúdo apagado com o atalho CTRL + Y.\n\n`•` **DELETE** : apaga o caractere à direita do cursor.\n\n`•` **CTRL + K** : apaga tudo o que estiver à direita do cursor, porém permite colar o\nconteúdo apagado com o atalho CTRL + Y.\n\n`•` **CTRL + L** : funciona como o comando clear, limpa a tela e joga o cursor para a primeira\nlinha. Com o atalho **SHIFT + PAGE UP**, ainda é possível visualizar o conteúdo.\n\n`•` **CTRL + C** : abre uma nova linha de comando na posição do cursor.\n\n`•` **CTRL + R** : busca algum caractere específico no último comando digitado.\n\n`•` **CTRL + D** : assim como o comando exit, sai do shell."
    },
    {
        "chapter_id": "13",
        "title": "Capítulo 13",
        "content": "# **13**\n\n## Tópicos para revisão do capítulo\n\nAtente para os tópicos a seguir. Eles devem ser estudados com muita atenção, pois representam\nos pontos mais importantes deste capítulo.\n\n```\n  •\n```\n\nOs sistemas GNU/Linux herdaram muitas características do padrão Unix, como a representação por arquivos de tudo que estiver no sistema, a característica case-sensitive,\na necessidade de permissões de execução de arquivos para todos os usuários, a divisão\ndo sistema em camadas, entre outras;\n\n`•` Existem basicamente três tipos de usuários no Linux: o usuário root ou superusuário,\nque possui funções administrativas, os usuários comuns e os usuários de sistema;\n\n```\n  •\n```\nO shell é o mediador entre o usuário e o computador num sistema Unix-like, já que é\nele o responsável por interpretar e executar os comandos enviados por um usuário;\n\n`•` O shell usado no sistema operacional GNU é chamado bash, e apresenta mais funcionalidades e praticidades na hora de realizar tarefas na linha de comandos do que seu\nantecessor, o interpretador de comandos sh;\n\n```\n  •\n```\nUma sessão é composta por um login efetuado com sucesso por um usuário previamente\ncadastrado no sistema;\n\n```\n  •\n```\nIniciar, desligar e reiniciar o sistema adequadamente são processos que fazem parte dos\nprimeiros comandos que devem ser compreendidos pelo usuário, já que sua execução\ninadequada pode gerar danos, como falhas no sistema de arquivos e perda de dados;\n\n```\n  •\n```\nHá diversos tipos de shell disponíveis para distribuições GNU/Linux. O bash é o tipo\nutilizado na maioria das distribuições, mas existem também outros, como sh, csh e zsh;\n\n```\n  •\n```\nPodemos definir variáveis como nomes que contêm algum valor e, ainda, como espaços\nde memória que armazenam valores. Sua função é o fornecimento de dados úteis e\n\n\n74\n\n\n75 13. Tópicos para revisão do capítulo\n\n\nnecessários a usuários e programas;\n\n```\n  •\n```\nAlguns arquivos são automaticamente lidos pelo shell no momento do login e do logout\nde um usuário ou ainda da inicialização do shell a partir de uma sessão que já tenha sido\niniciada. Com eles, o usuário pode programar a criação de variáveis, aliases (apelidos),\nfunções e outras personalizações do bash;\n\n`•` Para alterar o shell atual, utilizamos o comando chsh com a opção -s ou --shell, seguido\ndo nome do shell que se deseja utilizar;\n\n```\n  •\n```\nÉ possível atribuir um alias para executar um determinado comando com parâmetros\nespecíficos toda vez que o termo atribuído for usado;\n\n`•` Os arquivos /etc/issue, /etc/motd e /etc/issue.net operam na exibição de mensagens para\nusuários. Os dois primeiros exibem mensagens antes e depois do login, respectivamente,\ne o terceiro permite visualizar mensagens exibidas em logins remotos;\n\n`•` O arquivo .bash_history é um arquivo responsável por armazenar o histórico de linhas de\ncomando. Por padrão, até 500 comandos podem ser armazenados nesse arquivo.\n\n`•` Por meio do comando history, é possível acessar uma lista com o histórico de comandos\nanteriormente utilizados."
    },
    {
        "chapter_id": "14",
        "title": "Capítulo 14",
        "content": "# **14**\n\n## Como obter ajuda\n\nO ritmo de geração de conhecimento e informação tem sido vertiginoso nos últimos **sessenta**\n**anos**, especialmente na área tecnológica. Por isso é fundamental saber onde buscar informações para manter-se sempre atualizado. Neste capítulo, vamos aprender a consultar as\ndocumentações existentes e como buscar informações sobre o que precisamos.\n\n\nO Sistema Operacional **GNU/Linux** possui uma vasta biblioteca de documentação. Antes\nde recorrermos a ajuda de outras pessoas, devemos lembrar que podemos ter a respostas que\nprecisamos no próprio sistema, bem a nossa frente, ao teclar de um simples comando. Essa\ndocumentação em grande parte dos casos é de extrema qualidade.\n\n\nO **GNU/Linux** cresceu porque a comunidade contribui para o sistema e sua documentação.\nEssa comunidade não tem medo ou receio de compartilhar informações e disponibiliza o que\nfoi desenvolvido no próprio sistema. É muito importante reforçar que no Software Livre, as\npessoas nunca ocultam seu **know-how**, ou seja, você pode perguntar a vontade, desde que\nsaiba o que e onde perguntar.\n\n\nA documentação do GNU/Linux pode ser vista também como fonte de conhecimento, onde\npode-se aprender muito sobre cada um dos serviços e comandos disponíveis.\n\n\nEssa ajuda é provida por meio dos manuais, as famosas **Man Pages** .\n\n\nAbaixo vamos começar a nos familiarizar com a documentação existente e as formas nas quais\nela é apresentada.\n\n\n76"
    },
    {
        "chapter_id": "15",
        "title": "Capítulo 15",
        "content": "# **15**\n\n## Formas de documentação\n\nExistem diversas formas de se documentar um projeto, dentre elas temos os **Howto’s**, os\n**manuais** e as **documentações** .\n\n### **How-to’s**\n\n\nOs **How-to’s** (do inglês “Como Fazer”), são documentos que focam uma necessidade específica, como montar um “firewall”, instalar uma “webcam”, configurar placas de som, configurar\num servidor web e muitos outros. Normalmente esses documentos são instalados junto com\nsuas respectivas aplicações ou podem ter um pacote específico para a documentação daquela\naplicação. Os **how-to’s** também são conhecidos como **cook-books** - livro de receitas.\n\n\nO diretório de **How-to’s** do GNU/Linux é o /usr/share/doc. Se desejamos saber como configurar um **firewall**, podemos consultar os arquivos do diretório:\n\n\ncd /usr/share/doc/iptables/\n\n\nMuitas vezes o uso de **how-to’s** ou **cook-book’s**, não agrega um bom conhecimento, pois\ntrata-se somente de uma lista de afazeres para chegar a um objetivo. Quando o software é\natualizado, todo aquele conhecimento fica dependente de um novo **how-to** .\n\n\n77\n\n\n78 15. Formas de documentação\n\n### **Manuais**\n\n\nDiferente dos **How-to’s** os manuais não vão te mostrar um passo a passo ou mesmo te dar uma\nlista de afazeres. O principal objetivo do manual é te mostrar como as funcionalidades daquele\nsoftware podem ser usadas. Com o manual o aprendizado para a utilização da ferramenta é\nfacilitado, já que o mesmo possui alguns exemplos de usabilidade. Esses manuais podem ser\nencontrados através do comando **man**, o qual veremos ainda nesse capítulo, um pouco mais\nadiante.\n\n### **Documentação**\n\n\nA palavra documentação é muito intensa. Quando falamos em documentar uma ferramenta,\nestamos na realidade abrangendo uma série de outros itens importantes, dentre eles os **How-**\n**to’s** e os manuais. Com a documentação de um projeto é possível entender absolutamente\ntudo sobre o mesmo, ou seja, essa documentação deve mostrar todas as partes relacionadas\nao projeto.\n\n\nPodemos, por exemplo, citar a documentação de um projeto de rede, onde deve constar não\nsó documentos como **how-to’s** e manuais, mas sim todas as especificações dos componentes,\nbem como cabos, “switch’s” e “routers” dentre outros detalhes muito importantes.\n\n\nComo esse tipo de documentação é muito especifica, devemos consultar o site de cada projeto\nindividualmente.\n\n\nExistem diversos comandos de ajuda no GNU/Linux, vamos abordar cada um deles logo abaixo:"
    },
    {
        "chapter_id": "16",
        "title": "Capítulo 16",
        "content": "# **16**\n\n## Comando help\n\nO comando help provê ajuda para comandos internos do interpretador de comandos, ou seja,\n\n- comando help fornece ajuda rápida. Ele é muito útil para saber quais opções podem ser\nusadas com os comandos internos do interpretador de comandos (shell). Para visualizar uma\najuda rápida para todos os comandos internos do sistema, podemos fazer da seguinte forma:\n\n\nhelp\n\n\nCaso desejemos visualizar a ajuda rápida para somente um comando interno, usamos esta\noutra sintaxe:\n\n\nhelp [comando]\n\n\nO comando help somente mostra a ajuda para comandos internos.\n\n\nhelp type\n\n\n79\n\n\n80 16. Comando help\n\n\nO comando type mostra se cada nome de comando é um comando do UNIX, um comando\ninterno, um alias, uma palavra-chave do shell ou uma função de shell definida.\n\n\nVerifique o tipo do comando help que conheceremos a seguir:\n\n\nhelp help\n\n\nPara comandos externos, o help aparece como parâmetro. Por exemplo:\n\n\n[comando] --help\n\n\nDesse modo, caso desejemos visualizar uma ajuda rápida sobre um comando externo, devemos\nfazer da seguinte forma:\n\n\nls --help\n\n\nO parâmetro --help pode ser utilizado em qualquer comando para ter uma consulta rápida\ndos parâmetros que ele pode nos oferecer. É importante entender que --help é na verdade um\nparâmetro individual de cada comando, logo se um comando não tiver esse parâmetro existem\noutros meios para se obter ajuda. Não se esqueça de estudar as diferenças entre comandos\ninternos e externos."
    },
    {
        "chapter_id": "17",
        "title": "Capítulo 17",
        "content": "# **17**\n\n## Comando apropos\n\nO comando apropos ajuda o usuário quando ele não se lembra do comando exato, mas conhece\nalgumas palavras-chave relacionadas ao comando que definem seu uso ou funcionalidade. Ele\npesquisa a página de manual do Linux com a ajuda da palavra-chave fornecida pelo usuário\npara encontrar o comando e suas funções.\n\n\n**Sintaxe:**\n\n\napropos [OPÇÃO ..] PALAVRA-CHAVE ...\n\n\n**Situacao 1:** suponhamos que você não saiba como compactar um arquivo, então você poderia\ndigitar o seguinte comando no terminal e ele mostrará todos os comandos relacionados e sua\nbreve descrição ou funcionalidade.\n\n\napropos compress\n\n\nDepois de executar o comando acima, você observará uma série de comandos listados no\nterminal que tratam não apenas de como compactar um arquivo, mas também de expandir\num arquivo compactado, pesquisar um arquivo compactado, comparar um arquivo compactado\netc.\n\n\n81\n\n\n82 17. Comando apropos\n\n\n**Situacao 2:** - comando apropos também suporta várias palavras-chave se fornecidas como um\nargumento, ou seja, também podemos fornecer mais de uma palavra-chave para uma busca\nmelhor. Assim, se duas palavras-chave forem fornecidas, o comando apropos exibirá toda a\nlista do comando que contém a primeira palavra-chave em sua descrição de página de manual\nou a segunda palavra-chave.\n\n\napropos email\n\n\nEntrada 1 (com uma palavra-chave)\n\n\napropos email address\n\n\nEntrada 2 (com várias palavras-chave)\n\n\n**Opções:**\n\n\n`•` **-d** : esta opção é usada para emitir mensagens de depuração. Quando esta opção é\nusada, o terminal retorna diretórios man, caminho global, diretório do caminho, avisos,\netc. de cada comando que está relacionado à palavra-chave de pesquisa.\n\n`•` **-v** : esta opção é usada para imprimir mensagens de aviso detalhadas.\n\n`•` **-e**, **–exact** : esta opção é usada para pesquisar cada palavra-chave para correspondência\nexata. Se nenhuma opção for usada, o comando apropos retorna a lista de todos os\ncomandos cuja descrição na descrição da página do manual corresponde à palavra-chave\nou que estão de alguma forma relacionados à palavra-chave fornecida no argumento.\nNo entanto, quando a opção -e é usada, o apropos retorna apenas o comando cuja\ndescrição corresponde exatamente à palavra-chave.\n\n`•` **-w**, **–wildcard** : esta opção é usada quando a (s) palavra (s) -chave contém curingas.\n\napropos irá pesquisar independentemente o nome da página e a descrição que corresponde\nà (s) palavra (s) -chave.\n\n`•` **-a**, **–and** : esta opção é usada quando queremos que todas as palavras-chave correspondam. Ele não retorna nada se qualquer uma das palavras-chave fornecidas não\ntiver correspondência na página do manual ou na descrição. Na entrada abaixo, duas\npalavras-chave foram fornecidas e apenas dois comandos são exibidos no resultado, pois\nhá apenas um comando que contém ambas as palavras-chave.\n\n`•` **-l**, **–long** : por padrão, a saída é cortada para a largura do terminal. Esta opção é útil\n\n\n83 17. Comando apropos\n\n\nquando não queremos que o resultado seja truncado.\n\n`•` **-C** : esta opção é usada quando não queremos usar o padrão (/ manpath), mas o arquivo\nde configuração do usuário.\n\n`•` **-L** : define o local para esta pesquisa.\n\n`•` **-m**, **–systems** : esta opção usa páginas de manual de outros sistemas. Esta opção\né útil quando queremos pesquisar a descrição da página do manual de outro sistema\noperacional acessível.\n\n`•` **-M**, **–manpath** : define o caminho de pesquisa das páginas de manual para PATH em\nvez do $MANPATH padrão .\n\n`•` **-s**, **–sections**, **–section** : Esta opção é usada quando queremos pesquisar apenas\nseções particulares (separadas por dois pontos) que são fornecidas no argumento.\n\n`•` **-?**, **–Help** : esta opção exibe a lista de ajuda.\n\n`•` **-V**, **–version** : usado para imprimir a versão do programa.\n\n`•` **-r**, **–regex** : esta opção interpreta cada palavra-chave como um regex (expressão\nregular). A palavra-chave será comparada independentemente com o nome e a descrição\nda página.\n\n\nE por fim, uma forma equivalente ao apropos é usar o comando man juntamente com a opção\n\n-k\n\n\nman -k editor"
    },
    {
        "chapter_id": "18",
        "title": "Capítulo 18",
        "content": "# **18**\n\n## Comando whatis\n\nO comando whatis tem basicamente a mesma função do comando apropos, porém as buscas do\ncomando whatis são mais específicas. O apropos busca as páginas de manuais e descrições de\nmaneira mais genérica. Se digitarmos a palavra **passwd** ele nos trará tudo que tiver **passwd**,\nseja como nome ou parte do nome do manual ou na descrição. Já o whatis nos trará somente\n\n- manual com nome exato da palavra pesquisada.\n\n\nA sintaxe utilizada no comando whatis é a seguinte:\n\n\nwhatis [comando]\n\n\nVocê sabe que tem um programa chamado vim, mas não sabe o que ele faz?\n\n\nwhatis vim\n\n\nUma forma equivalente ao whatis é usar o comando man juntamente com a opção -f:\n\n\nman -f vim\n\n\n84\n\n\n85 18. Comando whatis\n\n\nPara localizar as **man pages**, o comando apropos e whatis utilizam o mesmo banco de dados\nconstruído com o comando catman ou makewhatis (executado pelo administrador do sistema,\n**root** ).\n\n\nPara construir o banco de dados do comando apropos e whatis devemos executar o comando\nabaixo:\n\n\n**Debian:**\n\n\ncatman\n\n\n**CentOS:**\n\n\nmakewhatis -v"
    },
    {
        "chapter_id": "19",
        "title": "Capítulo 19",
        "content": "# **19**\n\n## Comando man\n\nO comando man sem dúvidas é o comando mais usado para obtenção de documentação no\nLinux, ele é o responsável por trazer os manuais mais completos sobre determinado comando,\narquivo de configuração, bibliotecas, entre outros nos quais estamos trabalhando.\n\n\nOs manuais do sistema são divididos nos seguintes níveis:\n\n\n`•` **man 1** -> Programas e executáveis disponíveis ao usuário;\n\n`•` **man 2** -> Rotinas de sistema Unix e C;\n\n`•` **man 3** -> Rotinas de bibliotecas da linguagem C;\n\n`•` **man 4** -> Arquivos especiais (dispositivos em /dev);\n\n`•` **man 5** -> Arquivos de configuração e convenções;\n\n`•` **man 6** -> Games;\n\n`•` **man 7** -> Diversos (macros textuais, por exemplo, regex);\n\n`•` **man 8** -> Comandos administrativos;\n\n`•` **man 9** -> Rotinas internas do kernel.\n\n\nÉ comum o exame da LPI cobrar mais dos níveis 1, 5 e 8 dos manuais! Então lembre\nse de estudar binários, arquivos de configuração e comandos administrativos.\n\n\nSintaxe do comando man:\n\n\n86\n\n\n87 19. Comando man\n\n\nman [ comando ]\n\n\nou\n\n\nman [ seção ] [ comando ]\n\n\nUma curiosidade: as informações sobre as seções do comando man podem ser encontradas em seu próprio manual, digitando o comando man man.\n\n\nSe for necessário visualizar o manual do comando passwd, podemos fazer da seguinte forma:\n\n\nman passwd\n\n\nPara navegar pelo manual, o comando man abre um arquivo que está compactado na pasta /usr\n\n/share/man/man1 para o passwd. Outros níveis de manuais, dependem do comando ou arquivo.\nO passwd é conhecido no sistema **GNU/Linux** como um comando que adiciona ou modifica a\nsenha do usuário e, também, como o arquivo de usuários do sistema /etc/passwd).\n\n\nVeremos agora o manual do arquivo de usuários passwd:\n\n\nman 5 passwd\n\n\nPodemos consultar quais manuais estão disponíveis dentro do próprio diretório do man:\n\n\nls /usr/share/man/\n\n\nDentro desse diretório é possível ver todas as divisões dos manuais: os níveis, os idiomas e\nmais. Todos os níveis de manuais possuem sua determinada introdução que pode ser vista\ncom o comando:\n\n\nman <nivel> intro\n\n\n88 19. Comando man\n\n\nPodemos ver que para visualizar o manual do arquivo de usuário passwd precisamos informar\nem qual nível de manual ele se encontra, pois já existe um passwd no nível 1, que é o comando,\nentão ele aparece primeiro quando digitamos man passwd sem indicar o nível.\n\n\nEsse manual do arquivo passwd está compactado na pasta **/usr/share/man/man5** ."
    },
    {
        "chapter_id": "20",
        "title": "Capítulo 20",
        "content": "# **20**\n\n## Comando info\n\nAs **info pages** são como as páginas de manuais, porém são utilizadas com navegação entre\nas páginas. Elas são acessadas pelo comando info. Este é útil quando já sabemos o nome do\ncomando e só queremos saber qual sua respectiva função.\n\n\nA navegação nas **info pages** é feita através de nomes marcados com um **(*) **(hipertextos)**\n**que, ao pressionarmos** Enter **, nos leva até a seção correspondente, e** Backspace** volta\nà página anterior. Algo parecido com a navegação na Internet.\n\n\nPodemos também navegar pelas páginas com as teclas: * **n (next/próximo);** - **p (previ-**\n**ous/anterior);** - **u (up/sobe um nível)** .\n\n\nPara sair do comando info, basta pressionar a tecla q.\n\n\nSe for necessário exibir a lista de todos os manuais de comandos/programas disponíveis,\nexecute o comando abaixo sem nenhum argumento. Assim:\n\n\ninfo\n\n\nPara exibir as informações somente de um determinado comando, usaremos a seguinte sintaxe:\n\n\ninfo [comando]\n\n\n89\n\n\n90 20. Comando info\n\n\nVisualizar informações do comando vim:\n\n\ninfo vim\n\n### **Alternativas para consulta**\n\n\nPara obter uma melhor visualização, duas ferramentas de documentação foram desenvolvidas:\n\n\n`•` **yelp** -> Ferramenta gráfica para visualização de manuais de aplicativos gráficos do\nGNOME; (fornecido pelo pacote yelp);\n\n`•` **xman** -> “Front-end” para o comando man, que facilita a consulta das **man pages** ;\n(fornecido pelo pacote x11-apps)."
    },
    {
        "chapter_id": "21",
        "title": "Capítulo 21",
        "content": "# **21**\n\n## Comando whereis\n\nO comando whereis é utilizado para mostrar a localização do binário do comando, do arquivo de\nconfiguração (caso exista), e a localização das páginas de manuais do determinado comando\nou arquivo.\n\n\nSe compararmos o comando whereis com o comando find, eles parecerão semelhantes entre si,\npois ambos podem ser usados para os mesmos fins, mas o comando whereis produz o resultado\ncom mais precisão, consumindo menos tempo comparativamente.\n\n\n`•` **Exemplo 1:** digamos que queremos encontrar a localização do comando apropos e, em\nseguida, precisamos executar o seguinte comando no terminal:\n\n\nwhereis apropos\n\n\n`•` **Exemplo 2:** para encontrar a localização do comando lshw.\n\n\nwhereis lshw\n\n\n**Opcoes:**\n\n\n`•` **-b** : esta opção é usada quando queremos apenas pesquisar binários.\n\n\n91\n\n\n92 21. Comando whereis\n\n\n**Exemplo:** para localizar o binário de um comando do Linux, digamos gunzip.\n\n\nwhereis -b gunzio\n\n\n`•` **-m** : esta opção é usada quando queremos apenas pesquisar por seções manuais.\n\n\n**Exemplo:** Para localizar a página de manual do comando falso.\n\n\nwhereis -m false\n\n\n`•` **-s** : esta opção é usada quando queremos apenas pesquisar fontes.\n\n`•` **-u** : esta opção pesquisa entradas incomuns. Um arquivo de origem ou um arquivo\nbinário é considerado incomum se não tiver nenhuma existência no sistema de acordo\ncom [-bmsu] descrito junto com **–u** . Assim, whereis -m -u *pede os arquivos no diretório\natual que possuem entradas incomuns.\n\n\n**Exemplo** : Para exibir os arquivos do diretório atual que não possuem arquivo de\ndocumentação.\n\n\nwhereis -m -u *\n\n\n`•` **-B** : esta opção é usada para alterar ou limitar os locais onde o whereis procura por\nbinários.\n\n\n**Exemplo** : para localizar o binário de lesspipe no caminho, /bin.\n\n\nwhereis -B /bin -f lesspipe\n\n\n`•` **-M** : esta opção é usada para alterar ou limitar os locais onde o whereis procura por\nseções manuais.\n\n\n93 21. Comando whereis\n\n\n**Exemplo** : para verificar a página de manual de introdução que está apenas em um\nlocal específico, ou seja, /usr/share/man/man1.\n\n\nwhereis -M /usr/share/man/man1 -f intro\n\n\n`•` **-S** : esta opção é usada para alterar ou de outra forma limitar os locais onde whereis\nprocura pelas fontes.\n\n\n**Exemplo** : Para localizar todos os arquivos em /usr/bin que não estão documentados\nem /usr/man/man1 com fonte em /usr/src\n\n\nwhereis -u -M /usr/share/man/man1 -S /usr/src -f *\n\n\n`•` **-f** : esta opção simplesmente termina a última lista de diretórios e sinaliza o início dos\nnomes dos arquivos. Deve ser usado quando qualquer uma das opções -B, -M ou -S for\nusada.\n\n`•` **-V** : exibe informações sobre a versão e sai.\n\n`•` **-h** : exibe esta ajuda e sai."
    },
    {
        "chapter_id": "22",
        "title": "Capítulo 22",
        "content": "# **22**\n\n## Comando which\n\nO comando which é bem semelhante ao comando whereis, entretanto este só mostra a localização do binário do comando.\n\n\nPara visualizar a localização do binário do comando, utilizamos a seguinte sintaxe:\n\n\nwhich <comando>\n\n\nLocalização do binário do comando vim:\n\n\nwhich vim\n\n### **Tópicos para revisão do capítulo**\n\n\nAtente-se para os tópicos a seguir. Eles devem ser estudados com muita atenção, pois representam os pontos mais importantes deste capítulo.\n\n\n`•` O comando help somente mostra a ajuda para comandos internos.\n\n`•` apropos é um comando dos sistemas operacionais unix-like que mostra informações sobre\num assunto a partir de um banco de dados.\n\n`•` apropos usa o mesmo banco do comando whatis.\n\n\n94\n\n\n95 22. Comando which\n\n\n`•` Uma forma equivalente ao whatis é usar o comando man juntamente com a opção **-f** .\n\n```\n  •\n```\nÉ comum o exame cobrar mais dos níveis 1, 5 e 8 dos manuais! Então lembre-se de\nestudar binários, arquivos de configuração e comandos administrativos.\n\n`•` Nos sistemas operacionais do tipo Unix, o comando info lê a documentação armazenada\nno formato info, desenvolvido pela **Free Software Foundation** .\n\n`•` O comando whereis permite localizar arquivos binário, fonte e também as páginas de\nmanual de comandos especificados no Linux.\n\n`•` O comando man fornece ajuda sobre o funcionamento de comandos com sua respectiva\nsintaxe e opções;\n\n`•` O comando which localiza o arquivo executável associado a um determinado comando"
    },
    {
        "chapter_id": "23",
        "title": "Capítulo 23",
        "content": "# **23**\n\n## FHS, Hierarquia dos Diretórios\n\n### **Introdução teórica**\n\nQuem já teve algum contato com o **GNU/Linux**, mesmo que superficial, deve ter percebido a\npresença de vários diretórios (pastas) no sistema. Entretanto, eles estão organizados seguindo\n\n- padrão POSIX, com o qual você pode não estar muito familiarizado. Neste capítulo, vamos\nconhecer a organização, e explorar a estrutura de diretórios de um sistema **GNU/Linux** .\n\n\nDesde que o **GNU/Linux** foi criado, muito se tem feito para seguir um padrão em relação à\nestrutura de diretórios. O primeiro esforço para padronização de sistemas de arquivos para o\nGNU/Linux foi o **FSSTND - Filesystem Standard**, lançado no ano de 1994.\n\n\nCada diretório do sistema tem seus respectivos arquivos que são armazenados conforme regras\ndefinidas pela **FHS - Filesystem Hierarchy Standard** ou **Hierarquia Padrão do Sistema**\n**de Arquivos**, que define que tipo de arquivo deve ser guardado em cada diretório. Isso é muito\nimportante, pois o padrão ajuda a manter compatibilidade entre as distribuições existentes no\nmercado, permitindo que qualquer software escrito para o **GNU/Linux** seja executado em\nqualquer distribuição desenvolvida de acordo com os padrões **FHS** .\n\n\nAtualmente, o **FHS** está na sua versão 2.3, e é mantido pelo **Free Standard Group**, uma\norganização sem fins lucrativos formada por grandes empresas como HP, IBM, RedHat e Dell.\n\n\n96\n\n\n97 23. FHS, Hierarquia dos Diretórios\n\n\nÉ vital entender bem sobre a **FHS** para prova, é através dela que nós devemos fazer\nnossas atividades com o **GNU/Linux** em nosso dia-a-dia.\n\n### **Estrutura de Diretórios GNU/Linux**\n\n\nA estrutura de diretórios também é conhecida como “Árvore de Diretórios” porque tem a\nforma de uma árvore. Mas, antes de estudarmos a estrutura de diretórios, temos que entender\n\n- que são diretórios.\n\n\nUm diretório é o local onde os arquivos são guardados no sistema. O objetivo é organizar os\ndiferentes arquivos e programas. Pense nos diretórios como sendo as gavetas de um armário.\nCada gaveta guarda, normalmente, um tipo diferente de roupa, enquanto cada diretório guarda\num certo tipo específico de arquivo.\n\n\nO arquivo pode ser um texto, uma imagem, planilha, etc. Os arquivos devem ser identificados\npor nomes para que sejam localizados por quem deseja utilizá-los.\n\n\nUm detalhe importante a ser observado é que o **GNU/Linux** segue o padrão POSIX que é **case**\n**sensitive**, isto é, ele diferencia letras maiúsculas e minúsculas nos arquivos e diretórios.\n\n\nSendo assim, um arquivo chamado **Joatham** é diferente de um outro chamado **JOATHAM**\ne diferente de um terceiro, chamado **joatham** . Inteligente isso, não é?\n\n\nA árvore de diretórios do GNU/Linux tem a seguinte estrutura:\n\n\n98 23. FHS, Hierarquia dos Diretórios\n\n\nA seguir segue uma listagem da estrutura padrão dos diretórios e o que contém em cada um\ndeles.\n\n\n`•` /bin: comandos (binários) essenciais acessíveis a qualquer usuário;\n\n`•` /sbin: comandos (binários) essenciais administrativos;\n\n`•` /boot: arquivos estáticos do gerenciador de inicialização e imagem do kernel;\n\n`•` /dev: arquivos dispositivos (discos rígidos, placa de som, placa de vídeo, mouse, etc.,\nexceto placa de rede);\n\n`•` /etc: arquivos de configuração de sistema e de programas em geral;\n\n`•` /lib: bibliotecas essenciais do sistema;\n\n`•` /media: ponto de montagem para dispositivos removíveis;\n\n`•` /mnt: ponto de montagem para sistemas de arquivos temporários;\n\n`•` /opt: pacotes de software adicionais (proprietários);\n\n`•` /srv: dados providos por serviços de rede do sistema;\n\n`•` /var: dados variáveis (por exemplo: arquivos de log, cache, spool de impressão etc.);\n\n\n99 23. FHS, Hierarquia dos Diretórios\n\n\n`•` /home: diretórios pessoais dos usuários;\n\n`•` /root: diretório pessoal do usuário root;\n\n`•` /usr: hierarquia secundária. É chamado de hierarquia secundária pois é o maior diretório\ndo sistema após o diretório raiz. Todos os subdiretórios em localizados dentro do\ndiretório /usr não são essenciais e tem uma estrutura muito parecida com / do sistema:\n\n`•` /usr/sbin: binários administrativos não essenciais;\n\n`•` /usr/bin: binários não essenciais;\n\n`•` /usr/lib: bibliotecas não essenciais ao sistema;\n\n`•` /usr/share/man: documentações (manuais);\n\n`•` /usr/src: códigos-fonte, por exemplo: do kernel\n\n`•` /proc: armazena informações dinâmicas sobre o sistema operacional, como, processos,\ninformações sobre entrada e saída, interrupções, modelo do processador, versão do\nkernel, estatísticas sobre quanto tempo a máquina está ligada, quais sistemas de arquivos\nsuportados etc. Este diretório não existe no disco rígido e sim na memória RAM;\n\n`•` /sys: sistema de arquivos virtual como o /proc mas que armazena e permite modificações\nnos dispositivos conectados ao sistema;\n\n`•` /lost+found: armazena arquivos recuperados pelo sistema;\n\n`•` /run: informações sobre o sistema em execução desde o último boot, usuários logados e\nprocessos servidores em execução;\n\n`•` /tmp: arquivos temporários que são limpos durante a inicialização;\n\n\n\n\n\nA opção --color do comando ls serve para deixar colorido a listagem, ex: * Azul ->\nDiretório. * Branco -> Arquivo regular. * Verde -> Arquivo executável. * Azul claro\n-> Link simbólico. * Vermelho -> Arquivo compactado. * Rosa -> Imagem.\n\n\nEste é o principal diretório do **GNU/Linux**, e é representado por uma / (barra). É no diretório\nraiz que ficam todos os demais diretórios do sistema. Estes diretórios, que vamos conhecer\nagora, são chamados de **subdiretórios** pois estão dentro do diretório /.\n\n\n\n\n\n\n100 23. FHS, Hierarquia dos Diretórios\n\n\nO diretório /bin guarda os comandos essenciais para o funcionamento do sistema.\n\n\nEsse é um diretório público, sendo assim, os comandos que estão nele podem ser utilizados\npor qualquer usuário do sistema. Entre os comandos, estão: * /bin/ls; * /bin/cp; * /bin/mkdir;\n\n- /bin/cat;\n\n\nQualquer usuário pode executar estes comandos:\n\n\n┌\n--(joathamkali)-[~]\n\n`-$ /bin/ls /boot/grub┌\n\n\n--(rootkali)-[/home/joatham]\n\n`-# /bin/ls /boot/grub\n\n\n\n\n\nNo diretório /boot estão os arquivos estáticos necessários à inicialização do sistema, e o gerenciador de **boot** . O gerenciador de **boot** é um programa que permite escolher e carregar o\nsistema operacional que será iniciado.\n\n\n\n\n\nNo diretório /dev ficam todos os arquivos de dispositivos. O **GNU/Linux** faz a comunicação com os periféricos por meio de **links** especiais que ficam armazenados nesse diretório,\nfacilitando assim o acesso aos mesmos.\n\n\nPara verificar que seu mouse é reconhecido como um arquivo, tente olhar o conteúdo do\narquivo /dev/input/mice:\n\n\ncat /dev/input/mice\n\n\nRepare que os dados são binários e não é possível ler o arquivo com o comando cat. Caso seu\nterminal fique com caracteres estranhos utilize o comando reset para resetar o shell:\n\n\n101 23. FHS, Hierarquia dos Diretórios\n\n\nreset\n\n\nPara visualizar o conteúdo do arquivo /dev/input/mice execute o comando od que é utilizado\npara visualizar o conteúdo de um arquivo nos formatos: **hexadecimal**, **octal**, **ASCII** e nome\ndos caracteres. Este comando pode ser útil para um programador que deseja criar um programa\nconforme o movimento do mouse.\n\n\nod /dev/input/mice\n\n\nObserve o conteúdo do seu HD:\n\n\nhexdump /dev/sda\n\n\nO comando hexdump tambem é utilizado para visualizar o conteúdo de um arquivo nos formatos:\n**hexadecimal**, **octal**, **decimal**, **ASCII** .\n\n\n\n\n\nNo diretório /etc estão os arquivos de configuração do sistema. Nesse diretório vamos encontrar\nvários arquivos de configuração, tais como: **scripts** de inicialização do sistema, tabela do\nsistema de arquivos, configuração padrão para **logins** dos usuários, etc.\n\n\ncat /etc/passwd\n\n\nVamos pegar uma linha de exemplo:\n\n\njoatham:x:1000:1000:joatham:/home/joatham:/bin/bash\n\n\nVamos dividir esta linha em **campos**, onde cada campo é separado por : (dois pontos), então:\n\n\n102 23. FHS, Hierarquia dos Diretórios\n\n\n**Campo** **Significado**\n\n\njoatham Login do Usuario\nx Aqui diz que a senha esta\nno arquivo /etc/shadow. Se\nestivesse *, a conta estaria\ndesabilitada e se estivesse\nsem nada (::), a conta nao\nteria senha.\n1000 **UID (User**\n**IDentification)**, o numero\nde identificacao do usuario.\n1000 **GID (Group**\n**IDentification)**, o numero\nde identificacao do grupo\ndo usuario.\njoatham **GECOS** Comentarios do\nusuario, como nome,\ntelefone e etc.\n/home- O diretorio **HOME** do\n/joatham usuario.\n/bin/bash Shell do usuario, ou seja, o\nprograma que ira\ninterpretar os comandos\nque o usuario executar.\n\n\nVamos conhecer o arquivo /etc/shadow:\n\n\nmore /etc/shadow\n\n\nO comando more assim como o cat serve para ver o conteúdo de um arquivo que é, geralmente,\ntexto. A diferença entre o more e o cat é que o more faz uma pausa a cada tela cheia exibindo\numa mensagem --More, dando uma oportunidade ao usuário ler a tela.\n\n\nAperte **enter** para ir para a próxima linha ou espaço para ir para a próxima página e para sair\ndigite **q** .\n\n\nUma alternativa ao uso do comando more seria o uso do comando less, que implementa as\nmesmas funcionalidades que more e mais algumas, como a possibilidade de rolar a tela para\n\n\n103 23. FHS, Hierarquia dos Diretórios\n\n\ncima e para o lado quando o texto ocupa mais de **oitenta colunas** .\n\n\nA utilização dos comandos less e more se faz de maneira semelhante.\n\n\nless /etc/shadow\n\n\nVamos pegar uma linha de exemplo:\n\n\njoatham:$1$Tcnt$Eisi0J9Wh3fCEsz1:11983:0:99999:7:30::\n\n\nEste arquivo possui as senhas criptografadas dos usuários do sistema. Existe uma entada no\narquivo para cada usuário do sistema com os seguintes campos:\n\n\n**Campo** **Significado**\n\n\njoatham Login do Usuario.\n1Tcnt$Eisi0J9Wh3fCEsz1A senha criptografada.\n11983 O numero de dias que\nexistem de 01/01/1970 ate\na data da ultima\nmodificacao da senha.\n0 Numero de dias antes do\nsistema permitir uma nova\nmodificacao na senha.\n99999 Numero maximo de dias\nque o usuario pode ficar\ncom uma mesma senha\n7 Numero de dias, antes da\nexpiracao da senha, quando\n\n          - usuario e informado da\nnecessidade de alterar a\nsenha.\n30 Numero de dias apos a\nexpiracao da senha, quando\na conta passa a ser\nconsiderada inativa (o valor\n-1 significa que a conta fica\ninativa no mesmo dia da\ndata de expiracao).\n\n\n104 23. FHS, Hierarquia dos Diretórios\n\n\n**Campo** **Significado**\n\n\nNumero de dias\nque existem de\n01/01/1970 ate\na expiracao da\nsenha (o valor\n-1 significa que\nnao ha data de\nexpiracao).\ncampo\nreservado para\nuso futuro\n\n\nApenas o usuário root **(administrador do sistema)** tem permissão para acessar o arquivo\n\n/etc/shadow.\n\n\nO comando pwconv é usado para criar o arquivo shadow a partir do arquivo /etc/passwd, enquanto\n\n- comando pwunconv executa a operação inversa. Execute:\n\n\npwunconv\n\n\nVerifique que não existe mais o arquivo /etc/shadow:\n\n\ncat /etc/shadow\n\n\nVerifique que as senhas criptografadas estão agora no arquivo /etc/passwd através do comando\n\ngetent:\n\n\ngetent passwd\n\n\nPara voltar as senhas criptografadas, execute:\n\n\npwconv\n\n\n105 23. FHS, Hierarquia dos Diretórios\n\n\nAgora as senhas estão protegidas novamente!! Antigamente estes comandos eram utilizados\npara sistemas que não vinham com as senhas protegidas no /etc/shadow por padrão, hoje em\ndia praticamente todas as distribuições trazem o arquivo como padrão, então utilizamos o\ncomando para execução de scripts para facilitar a captura de senhas, como por exemplo a\nmigração de um servidor de e-mail, onde queremos manter a senha antiga do usuário\n\n\n\n\n\nNo diretório /lib estão as bibliotecas compartilhadas e módulos do kernel. As bibliotecas são\nfunções que podem ser utilizadas por vários programas.\n\n\nCada kernel têm seus próprios módulos, que ficam em: /lib/modules/<versão do kernel>/kernel\nSeparados por tipos em subdiretórios.\n\n\nPara saber sua versão do kernel execute:\n\n\nuname -r\n\n\nPara visualizar os tipos de módulos:\n\n\nls /lib/modules/$(uname -r)/kernel\n\n\n\n\n\nPonto de montagem para dispositivos removíveis, tais como:\n\n```\n  •\n```\n\nhd\n\n```\n  •\n```\ncd\n\n```\n  •\n```\ndvd\n\n```\n  •\n```\npendrive\n\n```\n  •\n```\ncameras\n\n\n106 23. FHS, Hierarquia dos Diretórios\n\n\n\n\n\nEste diretório é utilizado para montagem temporária de sistemas de arquivos, tais como compartilhamentos de arquivos entre **Windows e GNU/Linux**, **GNU/Linux e GNU/Linux**,\netc.\n\n\n\n\n\nNormalmente, é utilizado por programas proprietários ou que não fazem parte oficialmente da\ndistribuição.\n\n\n\n\n\nO diretório /sbin guarda os comandos utilizados para inicializar, reparar, restaurar e/ou recuperar o sistema. Isso quer dizer que esse diretório também contém comandos essenciais, mas\nos mesmos são utilizados apenas pelo usuário administrador **root** .\n\n\nEntre os comandos estão:\n\n\n`•` hatl\n\n`•` ifconfig\n\n`•` init\n\n`•` iptables\n\n\nOs usuários comuns não podem executar comandos do /sbin que alterem o sistema, apenas\nalguns para visualização.\n\n\n**Exemplo:** Visualizar IP configurado na placa **eth0** :\n\n\n┌\n--(joathamkali)-[~]\n\n`-$ /sbin/ifconfig eth0\n\n\n107 23. FHS, Hierarquia dos Diretórios\n\n\nCriar uma alias da interface **eth0**\n\n\n┌\n--(joathamkali)-[~]\n\n`-$ /sbin/ifconfig eth0:1 10.10.10.10\n\n\n\n\n\nDiretório para dados de serviços fornecidos pelo sistema, cuja aplicação é de alcance geral, ou\nseja, os dados não são específicos de um usuário. Por exemplo:\n\n\n`•` /srv/www (servidor web)\n\n`•` /srv/ftp (servidor ftp)\n\n\n\n\n\nDiretório para armazenamento de arquivos temporários. É utilizado principalmente para\nguardar pequenas informações que precisam estar em algum lugar até que a operação seja\ncompletada, como é o caso de um **download** .\n\n\nEnquanto não for concluído, o arquivo fica registrado em /tmp, e, assim que é finalizado, é\nencaminhado para o local correto.\n\n\n\n\n\nO diretório /usr contém programas que não são essenciais ao sistema e que seguem o padrão\n**GNU/Linux**, como, por exemplo, navegadores, gerenciadores de janelas, etc.\n\n### **Diretório /var**\n\n\n108 23. FHS, Hierarquia dos Diretórios\n\n\nls /var\n\n\nO diretório /var contém arquivos de dados variáveis. Por padrão, os programas que geram\narquivos de registro para consulta, mais conhecidos como **logs**, ficam armazenados nesse\ndiretório. Além do **log**, os arquivos que estão aguardando em filas, também ficam localizados\nem /var/spool.\n\n\nOs principais arquivos que se utilizam do diretório /var são:\n\n```\n  •\n```\n\nMensagens de e-mail\n\n```\n  •\n```\nArquivos a serem impressos\n\n\nls /var/spool\n\n```\n  •\n```\n\nArquivos de logs\n\n\nls /var/log\n\n\n\n\n\nO /proc é um diretório virtual, mantido pelo kernel, onde encontramos a configuração atual do\nsistema, dados estatísticos, dispositivos já montados, interrupções, endereços e estados das\nportas físicas, dados sobre as redes, etc.\n\n\nUtilize os paginadores more ou less para visualizar alguns arquivos:\n\n\nmore /proc/cpuinfo\n\n\n\n\n\n\n109 23. FHS, Hierarquia dos Diretórios\n\n\nPode-se dizer que esse diretório é um primo do diretório /proc. Dentro do diretório /sys\npodemos encontrar o quase o mesmo conteúdo do /proc, mas de uma forma bem mais\norganizada para nós administradores.\n\n\n\n\n\nOs diretórios /root e /home podem estar disponíveis no sistema, mas não precisam obrigatoriamente possuir este nome. Por exemplo, o diretório /home poderia se chamar /casa, que não\ncausaria nenhum impacto na estrutura do sistema.\n\n\nO /home contém os diretórios pessoais dos usuários cadastrados no sistema.\n\n\nO /root é o diretório pessoal do super usuário root.\n\n\nComo sabemos o **root** é o administrador do sistema, e pode alterar as configurações do\nsistema, configurar interfaces de rede, manipular usuários e grupos, alterar a prioridade dos\nprocessos, entre outras.\n\n\n**Dica** : Utilize uma conta de usuário normal em vez da conta root para operar seu sistema.\n\n\nUma razão para evitar usar privilégios root regularmente, é a facilidade de se cometer\ndanos irreparáveis; além do que, você pode ser enganado e rodar um programa **Mal-**\n**ware** (programa que obtém poderes do super usuário) comprometendo a segurança\ndo seu sistema sem que você saiba."
    },
    {
        "chapter_id": "24",
        "title": "Capítulo 24",
        "content": "# **24**\n\n## Aprendendo Comandos do GNU/Linux\n\nComandos são instruções passadas ao computador para executar uma determinada tarefa. No\nmundo **NIX (GNU/Linux,Unix)**, o conceito de comandos é diferente do padrão **MS-DOS** .\nUm comando é qualquer arquivo executável, que pode ser ou não criado pelo usuário.\n\n\nUma das tantas vantagens do **GNU/Linux** é a variedade de comandos que ele oferece, afinal,\npara quem conhece comandos, a administração do sistema acaba se tornando um processo\nmais rápido.\n\n\nO **Shell** é o responsável pela interação entre o usuário e o sistema operacional, interpretando\nos comandos.\n\n\nÉ no **Shell** que os comandos são executados.\n\n### **Extraindo mais do comando ls**\n\n\nO comando ls possui muitos parâmetros, veremos aqui as opções mais utilizadas. A primeira\ndelas é o -l que lista os arquivos ou diretórios de uma forma bem detalhada (quem criou, data\nde criação, tamanho, dono e grupo ao qual cada um pertence):\n\n\nls -l /\n\n\n110\n\n\n111 24. Aprendendo Comandos do GNU/Linux\n\n\ncrw-r--r-- 1 root root 10, 235 Mar 3 11:54 autofs\ndrwxr-xr-x 2 root root 140 Mar 3 11:54 block\nlrwxrwxrwx 1 root root 3 Mar 3 11:54 cdrom -> sr0\nbrw-rw---- 1 root disk 8, 0 Mar 3 11:54 sda\n-rw-r--r-- 1 root root 501 Aug 6 2019 updatedb.conf\n\n\nVeja que a saída desse comando é bem detalhada. Falando sobre os campos, para o primeiro\ncaractere temos algumas opções:\n\n\n\nd --> Indica que se trata de um diretório.\nl --> Indica que se trata de um **link** ( como se fosse um atalho também vamos falar sobre\n\n\n\nele depois).\n\n- --> Hífen, indica que se trata de um arquivo regular.\nc --> Indica que o arquivo é um dispositivo de caractere (sem buffer).\nb --> Indica que o arquivo é um dispositivo de bloco (com buffer).\nu --> \"Sinônimo para o tipo c\" indica que o arquivo é um dispositivo de caractere (sem\n\n\n\nbuffer).\ns --> Indica que o arquivo é um socket.\np -> Indica que o arquivo é um fifo, named pipe.\n\n\n\n**FIFO** - Sigla para **First In, First Out**, que em inglês significa primeiro a entrar, primeiro a\nsair. São amplamente utilizados para implementar filas de espera. Os elementos vão sendo\ncolocados no final da fila e retirados por ordem de chegada. Pipes | são um exemplo de\nimplementação de FIFO.\n\n\n**Buffer** - É uma região de memória temporária, usada para escrita e leitura de dados. Normalmente, os buffers são utilizados quando existe uma diferença entre a taxa em que os dados\nsão recebidos e a taxa em que eles podem ser processados.\n\n\n**Socket** - É um meio de comunicação por software entre um computador e outro. É uma\ncombinação de um endereço IP, um protocolo e um número de porta do protocolo.\n\n\nO campo **rw-r–r–** lista as permissões, enquanto os campos **root** indicam quem é o usuário e\ngrupo dono desse diretório que, no nosso caso, é o administrador do sistema, o usuário **root** .\nO número antes do dono indica o número de **hard links**, um assunto abordado apenas em\ncursos mais avançados.\n\n\nO campo **501** indica o tamanho do arquivo, e o campo **Mar 3 11:54** informa a data e hora\nem que o diretório foi criado. Finalmente, no último campo temos o nome do arquivo ou\ndiretório listado, que, no nosso exemplo, é o **updatedb.conf** .\n\n\nCom relação aos diretórios, é importante ressaltar que o tamanho mostrado não corresponde ao\nespaço ocupado pelo diretório e seus arquivos e subdiretórios. Esse espaço é aquele ocupado\npela entrada no sistema de arquivos que corresponde ao diretório. A opção -a lista todos\n\n\n112 24. Aprendendo Comandos do GNU/Linux\n\n\narquivos, inclusive os ocultos:\n\n\nls -a / root\n.. aptitude . bashrc . profile\n\n\nVeja que, da saída do comando anterior, alguns arquivos são iniciados por . **(ponto)** . Esses\narquivos são ocultos. No Linux, arquivos e diretórios ocultos são iniciados por um . **(ponto)** .\nListar arquivos de forma recursiva, ou seja, listar também os subdiretórios que estão dentro\ndo diretório /:\n\n\nls -R /\n\n\nComo listar os arquivos que terminam com a palavra **.conf** dentro do diretório /etc?\n\n\nls /etc/*.conf\n\n\nComo buscar no diretório raiz / todos os diretórios que terminem com a letra **n** ?\n\n\nls -ld /*n\n\n### **Criar arquivo**\n\n\nPara criar um arquivo, podemos simplesmente abrir um editor de texto e salvá-lo. Mas existem\noutras formas. Uma das formas mais simples é usando o comando touch:\n\n\ncd /tmp\ntouch procedimentos.txt\ntouch contas.pdf contas2.pdf contas3.pdf contas4.pdf\n\n### **Curingas**\n\n\nO significado da palavra curinga no dicionário é o seguinte: carta de baralho, que em certos\njogos, muda de valor e colocação na sequência. No sistema **GNU/Linux** é bem parecida a\nutilização desse recurso. Os curingas são utilizados para especificar um ou mais arquivos ou\n\n\n113 24. Aprendendo Comandos do GNU/Linux\n\n\ndiretórios.\n\n\nEles podem substituir uma palavra completa ou somente uma letra, seja para listar, copiar,\napagar, etc. São usados cinco tipos de curingas no **GNU/Linux** :\n\n\n**Campo** **Significado**\n\n\n - Utilizado para um nome\ncompleto ou restante de\num arquivo/diretório;\n? Esse curinga pode substituir\numa ou mais letras em\ndeterminada posição;\n! exclui da operação;\n\n[padrão] É utilizado para referência a\numa faixa de caracteres de\num arquivo /diretório.\n\n[a-z][0-9] Usado para trabalhar com\ncaracteres de a at é z\nseguidos de um caractere\nde 0 at é 9.\n\n[a,z][1,0] Usado para trabalhar com\nos caracteres a e z seguidos\nde um caractere 1 ou 0\nnaquela posição.\n\n[a-z,1,0] Faz referência do intervalo\nde caracteres de a at é z ou\n1 ou 0 naquela posição.\n\n[ˆ abc] Faz referência a qualquer\ncaracter exceto a, b e c.\n{padrão} Expande e gera strings para\npesquisa de padrões de um\narquivo /diretório.\nX{ab,01} Faz referência a sequência\nde caracteres Xab ou X01.\nX{a-e,10} Faz referência a sequência\nde caracteres Xa Xb Xc Xd\nXe X10.\n\n\n114 24. Aprendendo Comandos do GNU/Linux\n\n\nA barra invertida serve para escapar um caracter especial, ela é conhecida também\ncomo **backslash** .\n\n\nA diferença do método de expansão dos demais, é que a existência do arquivo ou diretório é\nopcional para resultado final. Isto é útil para a criação de diretórios.\n\n\nOs 5 tipos de curingas mais utilizados **( *, ?, [ ],, ! )** podem ser usados juntos.\n\n\nVejamos alguns exemplos:\n\n\nVamos criar 5 arquivos no diretório /srv utilizando o método de expansã\n\n\ncd /srv\ntouch curriculo{1,2,3}.txt curriculo{4,5}.new\n\n\nPodemos listá-los assim:\n\n\nls\ncurriculo1.txt curriculo2.txt curriculo3.txt curriculo4.new curriculo5.new\n\n\nVamos listar todos os arquivos do diretório /srv. Podemos usar o curinga “*” para visualizar\ntodos os arquivos do diretório:\n\n\nls *\ncurriculo1.txt curriculo2.txt curriculo3.txt curriculo4.new curriculo5.new\n\n\nPara listarmos todos os arquivos do diretório /srv que tenham **new** no nome:\n\n\nls *new*\ncurriculo4.new curriculo5.new\n\n\nListar todos os arquivos que começam com qualquer nome e terminam com **.txt** :\n\n\nls *.txt\ncurriculo1.txt curriculo2.txt curriculo3.txt procedimentos.txt\n\n\n115 24. Aprendendo Comandos do GNU/Linux\n\n\nListar todos os arquivos que começam com o nome **curriculo**, tenham qualquer caractere no\nlugar do curinga, e terminem com **.txt** :\n\n\nls curriculo?.txt\ncurriculo1.txt curriculo2.txt curriculo3.txt\n\n\nPara listar todos os arquivos que começam com o nome **curriculo**, tenham qualquer caractere entre o número **1-3** no lugar da 4ł letra e terminem com **.txt** . Neste caso, se obtém\numa filtragem mais exata, pois o curinga especifica qualquer caractere naquela posição e **[ ]**\nespecifica um intervalo de números ou letras que será usado:\n\n\nls curriculo[1-3].txt\ncurriculo1.txt curriculo2.txt curriculo3.txt\n\n\nPara listar todos **.txt** exceto o **curriculo2.txt** :\n\n\nls curriculo[!2].txt\ncurriculo1.txt curriculo3.txt\n\n\nPara listar os arquivos **curriculo4.new** e **curriculo5.new** podemos usar os seguintes métodos:\n\n\nls *.new\nls *new*\nls curriculo?.new\nls curriculo[4,5].*\nls curriculo[4,5].new\n\n\nExistem muitas outras sintaxes possíveis para obter o mesmo resultado. A mais indicada será\nsempre aquela que atender à necessidade com o menor esforço possível.\n\n\nA criatividade nesse momento conta muito. No exemplo anterior, a última forma resulta na\nbusca mais específica. O que pretendemos é mostrar como visualizar mais de um arquivo de\numa só vez. O uso de curingas é muito útil e pode ser utilizado em todas as ações do sistema\noperacional referentes aos arquivos e diretórios: copiar,apagar, mover e renomear.\n\n\n116 24. Aprendendo Comandos do GNU/Linux\n\n### **Criando diretórios**\n\n\nO comando mkdir é utilizado para criar um diretório no sistema. Um diretório é uma pasta\nonde você guarda seus arquivos. Exemplo:\n\n\nCriar o diretório **Suporte** :\n\n\ncd /srv\nmkdir Suporte\n\n\nCriar o diretório **Financeiro** e o subdiretório **Contas a Pagar** :\n\n\nmkdir -p Financeiro/Contas\\ a\\ Pagar\n\n\nA opção -p permite a criação de diretórios de forma recursiva. Para que um subdiretório exista,\n\n- seu diretório diretamente superior tem que existir. Portanto a criação de uma estrutura como\nRh/Processos/Cv’s exigiria a execução de três comandos mkdir.\n\n\nAlgo como:\n\n\nmkdir Rh\nmkdir Rh/Processos\nmkdir Rh/Processos/Cv’\\s\n\n\nA opção -p permite que toda essa estrutura seja criada em uma única linha. Assim:\n\n\nmkdir -p Rh/Processos/Cv’\\s\n\n### **Removendo arquivos/diretórios**\n\n\nO comando rm é utilizado para apagar arquivos, diretórios e susiretórios estejam eles vazios ou\nnão.\n\n\nExemplos:\n\n\nRemover os arquivos com extensão **txt** :\n\n\n117 24. Aprendendo Comandos do GNU/Linux\n\n\ncd /srv\nls\nrm curriculo?.txt\nls\n\n\nRemover o arquivo **curriculo4.new** pedindo confirmação:\n\n\nrm -i curriculo4.news\nrm: remover arquivo comum vazio ‘curriculo4.’new?\n\n\nA opção -i força a confirmação para remover o arquivo **curriculo4.new** .\n\n\nRemover o diretório **Rh** :\n\n\nrm -r Rh\n\n\nA opção -r ou -R indica recursividade, ou seja, a remoção deverá ser do diretório Rh e de todo\n\n- seu conteúdo.\n\n\nObservação: Muita atenção ao usar o comando rm! Uma vez que os arquivos e\ndiretórios removidos não podem mais ser recuperados!\n\n\nO comando rmdir é utilizado para remover diretórios vazios.\n\n\nExemplos:\n\n\nRemover o diretório **Suporte** :\n\n\nrmdir Suporte\n\n### **Copiar arquivos/diretórios**\n\n\nO comando cp serve para fazer cópias de arquivos e diretórios. Perceba que para lidar com\ndiretórios a opção -r ou -R tem que ser usada:\n\n\n118 24. Aprendendo Comandos do GNU/Linux\n\n\ncp arquivo-origem arquivo-destino\ncp arquivo-origem caminho/diretório-destino/\ncp -R diretório-origem nome-destino\ncp -R diretório-origem caminho/diretório-destino/\n\n\nUma opção do comando cp muito útil em nosso dia-a-dia é a opção -p, que faz com que a\ncópia mantenha os **meta-dados** dos arquivos, ou seja, não modifica a data e hora de criação,\nseus donos e nem suas permissões. Utilizar como **root** :\n\n\nsu - aluno\n$ touch teste\n$ ls -l\n$ exit\ncd / home / aluno\ncp -p teste teste2\ncp teste teste3\nls -l teste2 teste3\n\n### **Mover ou renomear arquivos/diretórios**\n\n\nO comando mv serve tanto para renomear um arquivo quanto para movê-lo:\n\n\nmv arquivo caminho/diretório-destino/\nmv arquivo novo-nome\nmv diretório novo-nome\nmv diretório caminho/diretório-destino/\n\n\nA movimentação de um arquivo é uma ação de cópia seguida de uma remoção.\n\n\nRenomeando arquivo:\n\n\nmv teste teste4\n\n\nMovendo arquivo:\n\n\nmv teste4 /tmp\n\n\nRenomeando diretório:\n\n\n119 24. Aprendendo Comandos do GNU/Linux\n\n\ncd /srv\nmv Financeiro financeiro\n\n\nMovendo diretório:\n\n\nmv financeiro /srv/Rh/"
    },
    {
        "chapter_id": "25",
        "title": "Capítulo 25",
        "content": "# **25**\n\n## Localização no sistema\n\n### **Comando find**\n\nO comando find procura por arquivos/diretórios no disco. Ele pode procurar arquivos pela\nsua data de modificação, tamanho, etc. O find, ao contrário de outros programas, usa opções\nlongas por meio de um -.\n\n\nSintaxe do comando find:\n\n\nfind [diretório] [opções/expressão]\n\n\n`•` **-name [expressão]** : Procura pela [expressão] definida nos nomes de arquivos e diretórios processados.\n\n\nfind /etc -name *.conf\n\n\n`•` **-maxdepth[num]** : Limita a recursividade de busca na árvore de diretórios. Por exemplo,\nlimitando a 1, a busca será feita apenas no diretório especificado e não irá incluir nenhum\nsubdiretório.\n\n\nfind /etc -maxdepth 1 -name *.conf\n\n\n120\n\n\n121 25. Localização no sistema\n\n\n`•` **-amin[num]** : Procura por arquivos que foram acessados [num] minutos atrás. Caso\nseja antecedido por -”, procura por arquivos que foram acessados entre [num] minutos\natrás e o momento atual.\n\n\nfind ~ -amin -5\n\n\n`•` **-atime[num]** : Procura por arquivos que foram acessados [num] dias atrás. Caso seja\nantecedido por -, procura por arquivos que foram acessados entre [num] dias atrás e a\ndata atual.\n\n\nfind ~ -atime -10\n\n\n`•` **-uid[num]** : Procura por arquivos que pertençam ao usuário com o **uid 1000** [num].\n\n\nfind / -uid 1000\n\n\n`•` **-user[nome]** : Procura por arquivos que pertençam ao usuário aluno [nome].\n\n\nfind / -user aluno\n\n\n`•` **-perm[modo]** :\n\n\nProcura por arquivos que possuem os modos de permissão [modo]. Os [modo] de permissão\npodem ser numérico (octal) ou literal.\n\n\nfind / -perm 644\n\n\n`•` **-size[num]** : Procura por arquivos que tenham o tamanho [num]. O tamanho é especificado em bytes. Você pode usar os sufixos k, M ou G para representar o tamanho\nem Quilobytes, Megabytes ou Gigabytes, respectivamente. O valor de [num] Pode ser\nantecedido de **+** ou **-** para especificar um arquivo maior ou menor que [num].\n\n\nfind / -size +1M\n\n\n122 25. Localização no sistema\n\n\n`•` **-type[tipo]** : Procura por arquivos do [tipo] especificado. Os seguintes tipos são aceitos:\n\n\n**b - bloco** ;\n\n\n**c - caractere** ;\n\n\n**d - diretório** ;\n\n\n**p - pipe** ;\n\n\n**f - arquivo regular** ;\n\n\n**l - link simbólico** ;\n\n\n**s - socket** .\n\n\nfind /dev -type b\n\n\n**Mais alguns exemplos que podem te ajudar no seu dia-a-dia..**\n\n\nO comando abaixo busca todos os arquivos ou diretórios que possuem permissão 777:\n\n\nfind / -perm 777\n\n\nO comando abaixo busca no diretório /root apenas arquivos com permissão 777:\n\n\nfind /root -type f -perm 777\n\n\n123 25. Localização no sistema\n\n\nO comando abaixo busca no diretório / apenas arquivos com tamanho maior do que 10M:\n\n\nfind / -size +10M\n\n\nO comando abaixo busca no diretório / arquivos com permissão 600 e executa o comando ls\nno formato longo para obter mais detalhes sobre os arquivos:\n\n\nfind / -perm 600 -exec ls -l {} \\;\n\n\nO comando abaixo busca no diretório / arquivos com permissão 600 e executa o comando ls\nno formato longo para obter mais detalhes sobre os arquivos:\n\n\nfind / -perm 600 -print0 | xargs -0 ls -l\n\n\nO comando abaixo buscará no diretório raiz apenas arquivos vazios:\n\n\nfind / -type f -empty\n\n\nO comando abaixo buscará no diretório raiz apenas diretórios vazios:\n\n\nfind / -type d -empty\n\n\nO comando abaixo buscará no diretório raiz todos os arquivo modificados nos 50 dias anteriores:\n\n\nfind / -mtime 50\n\n\nO comando abaixo buscará no diretório raiz todos arquivos que foram modificados entre 50 e\n100 dias atrás.\n\n\nfind / -mtime +50 -mtime -100\n\n\n124 25. Localização no sistema\n\n\nO comando abaixo buscará no diretório raiz todos arquivos que foram acessados nos últimos\n50 dias:\n\n\nfind / -atime 50\n\n\nO comando abaixo buscará no diretório corrente apenas arquivos que foram acessados no\núltimo dia (nas últimas 24 horas) e executará o comando ls no formato longo (detalhado) na\npossível lista de arquivos que será gerada:\n\n\nfind . -type f -atime -1 -exec ls -l {} \\;\n\n\nO comando abaixo buscará no diretório pessoal do usuário que estiver executando todos os\narquivos modificados nos últimos 60 minutos (1 hora):\n\n\nfind ~ -cmin -60\n\n\nO comando abaixo buscará no diretório raiz todos os arquivos com extensão .txt e retirará a\npermissão de execução de todos eles:\n\n\nfind / -name \"*.txt\" -exec chmod -x {} \";\"\n\n\nO comando abaixo buscará arquivos que tem todas as permissões citadas em -perm, neste caso\n4000:\n\n\nfind / -perm -4000\n\n\nO comando abaixo buscará um arquivo com o nome passwd até dois níveis (subdiretórios)\nabaixo da raiz:\n\n\nfind / -maxdepth 2 -name passwd\n\n\nO comando abaixo buscará no diretório corrente (ponto (.) após o find) diretórios vazios e os\n\n\n125 25. Localização no sistema\n\n\nremoverá:\n\n\nfind . -type d -empty -exec rmdir {} \\;\n\n### **Comando xargs**\n\n\nOutra forma de procurar por arquivos e/ou diretórios e executar um comando é através do\ncomando xargs que obtém como a entrada a saída ok do comando antes do pipe e envia como\nstdin do próximo comando, no caso o ls -ld:\n\n\nfind / etc -type d | xargs ls -ld\n\n\nVamos agora listar diretórios utilizando o xargs:\n\n\nls / | xargs - n1\nls / | xargs - n2\nls / | xargs - n3\n\n\nOutros testes com o xargs:\n\n\nls / > teste_xargs.txt\ncat teste_xargs.txt\ncat teste_xargs.txt | xargs -n 2\nxargs -n 3 < teste_xargs.txt\n\n\nVocê percebeu que no primeiro comando ele listou o diretório, jogando na tela um nome de\ncada vez. O segundo comando fará o mesmo só que com dois nomes na mesma linha, e o\nterceiro com 3 nomes.\n\n\necho \"linux:macos:freebsd:openbsd\" > /tmp/teste.txt\ncat /tmp/teste.txt | xargs -d: -n 2\nlinux macos\nfreebsd openbsd\n\n\n126 25. Localização no sistema\n\n### **Comando locate**\n\n\nO comando locate é um comando rápido de busca de arquivos, porém não usa busca recursiva\nna sua árvore de diretórios. Ele utiliza uma base de dados que é criada pelo comando updatedb,\npara que a busca seja mais rápida. Por padrão, a atualização da base de dados é agendado\nno cron do sistema para ser executada diariamente.\n\n\nPara utilizá-lo, primeiro é necessário criar a sua base de dados usando a seguinte sintaxe:\n\n\nupdatedb\n\n\nQuando esse comando é executado pela primeira vez costuma demorar um pouco. Isso deve-se\na primeira varredura do disco para a criação da primeira base de dados.\n\n\nPara o comando locate, usamos a seguinte sintaxe:\n\n\nlocate howto\n\n\nA saída do comando será algo parecido com:\n\n\n/usr/share/doc/hashcat/extra/tab_completion/howto.txt\n/usr/share/doc/smartmontools/badblockhowto.html\n/usr/share/doc/util-linux/howto-build-sys.txt\n/usr/share/doc/util-linux/howto-compilation.txt\n/usr/share/doc/util-linux/howto-contribute.txt.gz"
    },
    {
        "chapter_id": "26",
        "title": "Capítulo 26",
        "content": "# **26**\n\n## Tópicos para revisão do capítulo\n\nAtente-se para os tópicos a seguir. Eles devem ser estudados com muita atenção, pois representam os pontos mais importantes deste capítulo.\n\n```\n  •\n```\n\nOs diretórios no Linux são organizados de acordo com o padrão FHS – _Filesystem_\n_Hierarchy Standard_\n\n`•` O comando touch cria um arquivo vazio e também pode ser usado para modificar a data\nde criação/modificação de um arquivo ou diretório. O comando file mostra o tipo de\num arquivo.\n\n`•` O comando mkdir é usado para criar diretórios. O parâmetro -p é usado para não\nsobrescrever um diretório caso ele já exista.\n\n`•` O comando rm é usado para remover arquivos ou diretórios. O parâmetro -i faz uma\npergunta para confirmar a remoção do arquivo. O argumento -r serve para remover o\nconteúdo do diretório e o parâmetro -f força a remoção dos arquivos.\n\n`•` O comando find faz busca por arquivos e diretórios por meio de suas características, por\nexemplo, dono, grupo, permissões, tamanho, tipo de arquivo etc.\n\n`•` A função do comando xargs é construir listas de parâmetros e passá-la para a execução\nde outros programas ou instruções.\n\n`•` O comando locate é usado para buscar em uma base dados gerada pelo comando updatedb\n.\n\n\n127"
    }
]